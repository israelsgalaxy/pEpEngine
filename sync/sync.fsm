// This file is under BSD License 2.0

// Sync protocol for p≡p
// Copyright (c) 2016-2019, p≡p foundation

// Written by Volker Birk

include ./fsm.yml2

protocol Sync 1 {
    // all messages have a timestamp, time out and are removed after timeout

    fsm KeySync 1 {
        version 1, 2;

        state InitState {
            on Init {
                if deviceGrouped
                    go Grouped;
                go Sole;
            }
        }

        state Sole timeout=off {
            on Init {
                do newChallenge;
                do closeTransaction;
                send Beacon;
            }

            on KeyGen
                send Beacon;

            on CannotDecrypt // cry baby
                send Beacon;

            on Beacon {
                if sameChallenge {
                    // this is our own beacon; ignore
                }
                else {
                    if weAreFirst {
                        send Beacon;
                    }
                    else /* we are second */ {
                        do storeChallenge; // partner's challenge
                        do openTransaction; // NOP if transaction already open
                        do storeTransaction;
                        do tellWeAreNotGrouped;
                        // second is sending HandshakeRequest
                        send HandshakeRequest;
                    }
                }
            }

            on HandshakeRequest if challengeAccepted {
                if sameTransaction {
                    // this is our own handshake request; ignore
                }
                else {
                    // first is receiving HandshakeRequest
                    do storeTransaction;
                    // first is sending HandshakeAnswer
                    send HandshakeAnswer;
                    if partnerIsGrouped
                        go HandshakingWithGroup;
                    go HandshakingNewFirst;
                }
            }

            on HandshakeAnswer if sameTransaction {
                // second is receiving HandshakeAnswer
                go HandshakingNewSecond;
            }
        }

        // handshaking without existing Device group
        state HandshakingNewFirst {
            on Init
                do showSoleHandshake;

            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Rollback if sameTransaction
                go Sole;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on CommitReject if sameTransaction {
                do disable;
                go End;
            }

            // Accept means init Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAccept;
                go HandshakingNewPhase1First;
            }

            // got a CommitAccept from second
            on CommitAcceptForGroup if sameTransaction
                go HandshakingNewPhase2First;
        }

        // handshaking without existing Device group
        state HandshakingNewSecond {
            on Init
                do showSoleHandshake;

            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Rollback if sameTransaction
                go Sole;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on CommitReject if sameTransaction {
                do disable;
                go End;
            }

            // Accept means init Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAcceptForGroup;
                go HandshakingNewPhase1Second;
            }

            // got a CommitAccept from first
            on CommitAccept if sameTransaction
                go HandshakingNewPhase2Second;
        }

        state HandshakingNewPhase1First {
            on Rollback if sameTransaction
                go Sole;
            
            on CommitReject if sameTransaction {
                do disable;
                go End;
            }

            on CommitAcceptForGroup if sameTransaction
                go NewGroupFirst;
        }

        state HandshakingNewPhase1Second {
            on Rollback if sameTransaction
                go Sole;
            
            on CommitReject if sameTransaction {
                do disable;
                go End;
            }

            on CommitAccept if sameTransaction
                go NewGroupSecond;
        }

        state HandshakingNewPhase2First {
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on Accept {
                do trustThisKey;
                go NewGroupFirst;
            }
        }

        state HandshakingNewPhase2Second {
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on Accept {
                do trustThisKey;
                go NewGroupSecond;
            }
        }

        state NewGroupFirst {
            on Init {
                do prepareOwnKeys;
                send GroupKeys; // we're not grouped yet, this is our own keys
            }

            on GroupKeysAndClose if sameTransaction {
                if keyElectionWon
                    do ownKeysAreGroupKeys;
                else
                    do receivedKeysAreGroupKeys;
                go Grouped;
            }
        }

        state NewGroupSecond {
            on Init {
                do prepareOwnKeys;
                send GroupKeysAndClose; // we're not grouped yet, this is our own keys
            }

            on GroupKeys {
                if keyElectionWon
                    do ownKeysAreGroupKeys;
                else
                    do receivedKeysAreGroupKeys;
                go Grouped;
            }
        }

        state Grouped timeout=off {
            on Init
                do closeTransaction;

            on GroupKeys
                do saveGroupKeys;

            on KeyGen
                send GroupKeys;

            on Beacon {
                do storeChallenge;
                do openTransaction;
                do storeTransaction;
                do tellWeAreGrouped;
                send HandshakeRequest;
            }

            on HandshakeAnswer if sameTransaction
                go HandshakingGrouped;
        }

        // sole device handshaking with group
        state HandshakingWithGroup {
            on Init
                do showJoinGroupHandshake;

            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Rollback if sameTransaction
                go Sole;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on CommitReject if sameTransaction {
                do disable;
                go End;
            }

            // Accept is Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAccept;
                go HandshakingJoinPhase1;
            }

            on CommitAcceptForGroup if sameTransaction
                go HandshakingJoinPhase2;
        }

        state HandshakingJoinPhase1 {
            on Rollback if sameTransaction
                go Sole;
            
            on CommitReject if sameTransaction {
                do disable;
                go End;
            }

            on CommitAcceptForGroup if sameTransaction
                go JoinGroup;
        }

        state HandshakingJoinPhase2 {
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on Accept {
                do trustThisKey;
                go OwnGroup;
            }
        }

        state JoinGroup {
            on GroupKeysAndClose {
                send GroupKeys; // first send own keys
                do saveGroupKeys; // then store new group keys
                go Grouped;
            }
        }

        state OwnGroup {
            on GroupKeys {
                send GroupKeys; // first send own keys
                do saveGroupKeys; // then store new group keys
                go Grouped;
            }
        }

        state HandshakingGrouped {
            on Init
                do showGroupedHandshake;
    
            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Grouped;
            }

            on Rollback if sameTransaction
                go Grouped;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                go Grouped;
            }

            on CommitReject if sameTransaction
                go Grouped;

            // Accept is Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAcceptForGroup;
                go HandshakingGroupedPhase1;
            }

            on CommitAccept if sameTransaction
                go HandshakingGroupedPhase1Own;

            on GroupKeys
                do saveGroupKeys;
        }

        state HandshakingGroupedPhase1 {
            on Rollback if sameTransaction
                go Grouped;

            on CommitReject if sameTransaction
                go Grouped;

            on CommitAccept if sameTransaction {
                send GroupKeysAndClose;
                go Grouped;
            }

            on GroupKeys
                do saveGroupKeys;
        }

        state HandshakingGroupedPhase1Own {
            on Cancel {
                send Rollback;
                go Grouped;
            }

            on Reject {
                send CommitReject;
                go Grouped;
            }

            on Accept {
                do trustThisKey;
                send GroupKeysAndClose;
                go Grouped;
            }

            on GroupKeys
                do saveGroupKeys;
        }
 
        external Accept 129;
        external Reject 130;
        external Cancel 131;

        // beacons are always broadcasted

        message Beacon 2, type=broadcast, security=unencrypted {
            field TID challenge;
            auto Version version;
        }

        message HandshakeRequest 3, security=untrusted {
            field TID challenge;
            auto Version version;
            field TID transaction;
            field bool is_group;
        }

        message HandshakeAnswer 4, security=untrusted {
            auto Version version;
            field TID transaction;
        }

        message Rollback 5, security=untrusted {
            field TID transaction;
        }

        message CommitReject 6, security=untrusted {
            field TID transaction;
        }

        message CommitAccept 7, security=untrusted {
            field TID transaction;
        }

        message CommitAcceptForGroup 8, security=untrusted {
            field TID transaction;
        }

        message GroupKeysAndClose 9, security=attach_own_keys {
            field TID transaction;
            field IdentityList ownIdentities;
        }

        message GroupKeys 10, security=attach_own_keys {
            field IdentityList ownIdentities;
        }
    }
}

