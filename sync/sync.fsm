// This file is under BSD License 2.0

// Sync protocol for p≡p
// Copyright (c) 2016-2019, p≡p foundation

// Written by Volker Birk

include ./fsm.yml2

protocol Sync 1 {
    // all messages have a timestamp, time out and are removed after timeout

    fsm KeySync 1, threshold=30 {
        version 1, 2;

        state InitState {
            on Init {
                if deviceGrouped
                    go Grouped;
                go Sole;
            }
        }

        state Sole timeout=off {
            on Init {
                do closeTransaction;
                do newChallenge;
                do showBeingSole;
                send Beacon;
            }

            on KeyGen {
                send Beacon;
            }

            on CannotDecrypt { // cry baby
                send Beacon;
            }

            on Beacon {
                if sameChallenge {
                    // this is our own Beacon; ignore
                }
                else {
                    if weAreFirst {
                        send Beacon;
                    }
                    else /* we are second */ {
                        do newTransaction;
                        do tellWeAreNotGrouped;
                        // second is sending NegotiationRequest
                        do replyChallenge; // partner's challenge
                        send NegotiationRequest;
                        do useOwnChallenge;
                    }
                }
            }

            on NegotiationRequest {
                if challengeAccepted {
                    if sameTransaction {
                        // this is our own NegotiationRequest; ignore
                    }
                    else {
                        // first is receiving NegotiationRequest
                        do storeTransaction;
                        // first is sending NegotiationOpen
                        send NegotiationOpen;
                        if partnerIsGrouped
                            go HandshakingWithGroup;
                        go HandshakingNewFirst;
                    }
                }
            }

            on NegotiationOpen if sameTransactionAndPartner {
                // second is receiving NegotiationOpen
                go HandshakingNewSecond;
            }
        }

        // handshaking without existing Device group
        state HandshakingNewFirst {
            on Init
                do showSoleHandshake;

            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Rollback if sameTransactionAndPartner
                go Sole;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on CommitReject if sameTransactionAndPartner {
                do disable;
                go End;
            }

            // Accept means init Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAcceptFirst;
                go HandshakingNewPhase1First;
            }

            // got a CommitAccept from second
            on CommitAcceptSecond if sameTransactionAndPartner
                go HandshakingNewPhase2First;
        }

        // handshaking without existing Device group
        state HandshakingNewSecond {
            on Init
                do showSoleHandshake;

            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Rollback if sameTransactionAndPartner
                go Sole;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on CommitReject if sameTransactionAndPartner {
                do disable;
                go End;
            }

            // Accept means init Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAcceptSecond;
                go HandshakingNewPhase1Second;
            }

            // got a CommitAccept from first
            on CommitAcceptFirst if sameTransactionAndPartner
                go HandshakingNewPhase2Second;
        }

        state HandshakingNewPhase1First {
            on Rollback if sameTransactionAndPartner {
                do untrustThisKey;
                go Sole;
            }
            
            on CommitReject if sameTransactionAndPartner {
                do untrustThisKey;
                do disable;
                go End;
            }

            on CommitAcceptSecond if sameTransactionAndPartner {
                go NewGroupFirst;
            }
        }

        state HandshakingNewPhase1Second {
            on Rollback if sameTransactionAndPartner {
                do untrustThisKey;
                go Sole;
            }
            
            on CommitReject if sameTransactionAndPartner {
                do untrustThisKey;
                do disable;
                go End;
            }

            on CommitAcceptFirst if sameTransactionAndPartner {
                go NewGroupSecond;
            }
        }

        state HandshakingNewPhase2First {
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on Accept {
                send CommitAcceptFirst;
                do trustThisKey;
                go NewGroupFirst;
            }
        }

        state HandshakingNewPhase2Second {
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on Accept {
                send CommitAcceptSecond;
                do trustThisKey;
                go NewGroupSecond;
            }
        }

        state NewGroupFirst {
            on Init {
                do prepareOwnKeys;
                send OwnKeysFirst; // we're not grouped yet, this is our own keys
            }

            on OwnKeysSecond {
                do saveGroupKeys;

                if keyElectionWon
                    do ownKeysAreGroupKeys;
                else
                    do receivedKeysAreGroupKeys;
                do showGroupCreated;
                go Grouped;
            }
        }

        state NewGroupSecond {
            on Init {
                do prepareOwnKeys;
                send OwnKeysSecond; // we're not grouped yet, this is our own keys
            }

            on OwnKeysFirst {
                do saveGroupKeys;

                if keyElectionWon
                    do ownKeysAreGroupKeys;
                else
                    do receivedKeysAreGroupKeys;
                do showGroupCreated;
                go Grouped;
            }
        }

        state Grouped timeout=off {
            on Init {
                do closeTransaction;
                do newChallenge;
                do showBeingInGroup;
            }

            on GroupKeys
                do saveGroupKeys;

            on KeyGen {
                do prepareOwnKeys;
                send GroupKeys;
            }

            on Beacon {
                do newTransaction;
                do tellWeAreGrouped;
                do replyChallenge; // partner's challenge
                send NegotiationRequest;
                do useOwnChallenge;
            }

            on NegotiationOpen if sameTransactionAndPartner
                go HandshakingGrouped;

            on GroupTrustThisKey {
                do trustThisKey;
            }
        }

        // sole device handshaking with group
        state HandshakingWithGroup {
            on Init
                do showJoinGroupHandshake;

            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Rollback if sameTransactionAndPartner
                go Sole;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on CommitReject if sameTransactionAndPartner {
                do disable;
                go End;
            }

            // Accept is Phase1Commit
            on Accept {
                do trustThisKey;
                send CommitAccept;
                go HandshakingJoinPhase1;
            }

            on CommitAcceptForGroup if sameTransactionAndPartner
                go HandshakingJoinPhase2;
        }

        state HandshakingJoinPhase1 {
            on Rollback if sameTransactionAndPartner
                go Sole;
            
            on CommitReject if sameTransactionAndPartner {
                do disable;
                go End;
            }

            on CommitAcceptForGroup if sameTransactionAndPartner {
                go JoinGroup;
            }
        }

        state HandshakingJoinPhase2 {
            on Cancel {
                send Rollback;
                go Sole;
            }

            on Reject {
                send CommitReject;
                do disable;
                go End;
            }

            on Accept {
                do trustThisKey;
                go JoinGroup;
            }
        }

        state JoinGroup {
            on Init {
                do prepareOwnKeys;
                send OwnKeys;
            }

            on GroupKeys {
                do saveGroupKeys;
                do receivedKeysAreGroupKeys;
                do showDeviceAdded;
                go Grouped;
            }
        }

        state HandshakingGrouped {
            on Init
                do showGroupedHandshake;
    
            // Cancel is Rollback
            on Cancel {
                send Rollback;
                go Grouped;
            }

            on Rollback if sameTransactionAndPartner
                go Grouped;

            // Reject is CommitReject
            on Reject {
                send CommitReject;
                go Grouped;
            }

            on CommitReject if sameTransactionAndPartner
                go Grouped;

            // Accept is Phase1Commit
            on Accept {
                do trustThisKey;
                send GroupTrustThisKey;
                send CommitAcceptForGroup;
                go HandshakingGroupedPhase1;
            }

            on CommitAccept if sameTransactionAndPartner
                go HandshakingGroupedPhase2;

            on GroupTrustThisKey {
                do hideHandshakeDialog;
                do trustThisKey;
            }

            on CommitAcceptForGroup {
                do showDeviceAdded;
                if sameTransactionAndPartner {
                    do hideHandshakeDialog;
                    go Grouped;
                }
            }

            on GroupKeys
                do saveGroupKeys;
        }

        state HandshakingGroupedPhase1 {
            on Rollback if sameTransactionAndPartner
                go Grouped;

            on CommitReject if sameTransactionAndPartner
                go Grouped;

            on CommitAccept if sameTransactionAndPartner {
                send GroupKeys;
                go Grouped;
            }

            on GroupTrustThisKey {
                do trustThisKey;
            }

            on CommitAcceptForGroup {
                do showDeviceAdded;
                if sameTransactionAndPartner
                    go Grouped;
            }

            on GroupKeys
                do saveGroupKeys;
        }

        state HandshakingGroupedPhase2 {
            on Cancel {
                send Rollback;
                go Grouped;
            }

            on Reject {
                send CommitReject;
                go Grouped;
            }

            on Accept {
                do trustThisKey;
                send GroupTrustThisKey;
                send GroupKeys;
                go Grouped;
            }

            on GroupTrustThisKey {
                do trustThisKey;
            }

            on CommitAcceptForGroup {
                do showDeviceAdded;
                if sameTransactionAndPartner {
                    do hideHandshakeDialog;
                    go Grouped;
                }
            }

            on GroupKeys
                do saveGroupKeys;
        }
 
        external Accept 129;
        external Reject 130;
        external Cancel 131;

        // beacons are always broadcasted

        message Beacon 2, type=broadcast, security=unencrypted {
            field TID challenge;
            auto Version version;
        }

        message NegotiationRequest 3, security=untrusted {
            field TID challenge;
            auto Version version;
            field TID negotiation;
            field bool is_group;
        }

        message NegotiationOpen 4, security=untrusted {
            auto Version version;
            field TID negotiation;
        }

        message Rollback 5, security=untrusted {
            field TID negotiation;
        }

        message CommitReject 6, security=untrusted {
            field TID negotiation;
        }

        message CommitAcceptFirst 7, security=untrusted {
            field TID negotiation;
        }

        message CommitAcceptSecond 8, security=untrusted {
            field TID negotiation;
        }

        message CommitAccept 9, security=untrusted {
            field TID negotiation;
        }

        message CommitAcceptForGroup 10, security=untrusted {
            field TID negotiation;
        }

        // default: security=trusted only
        message GroupTrustThisKey 11 {
            field Hash key;
        }

        // trust in future
        message GroupKeys 12, security=attach_own_keys {
            field IdentityList ownIdentities;
        }

        message OwnKeys 13, security=attach_own_keys {
            field IdentityList ownIdentities;
        }

        message OwnKeysFirst 14, security=attach_own_keys {
            field IdentityList ownIdentities;
        }

        message OwnKeysSecond 15, security=attach_own_keys {
            field IdentityList ownIdentities;
        }
    }
}

