// This file is under GNU General Public License 3.0
// see LICENSE.txt

// generate message functions

// Copyleft (c) 2017, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {

include standardlib.ysl2
include ./functions.ysl2

template "/" {
    apply "protocol", 0, mode=header;
    apply "protocol", 0, mode=impl;
}

template "protocol", mode=header
    document "generated/{@name}_func.h", "text"
||
// This file is under GNU General Public License 3.0
// see LICENSE.txt

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>

#include "../asn.1/«@name».h"
`` for "func:distinctType(fsm/message/field[not(func:basicType())])" | #include "../asn.1/«@type».h"

// state

struct «@name»_state_s {
    struct basic_state_s {
        pEp_identity *from;
    } basic;

    `` apply "fsm", mode=state
};

struct own_«@name»_state_s {
    `` for "func:distinctName(fsm/message/field[@type='TID'])" |> «func:ctype()» «@name»;
};

void free_«@name»_state(PEP_SESSION session);

// functions for protocol «@name»

«@name»_t *new_«@name»_message(«@name»_PR fsm, int message_type);
void free_«@name»_message(«@name»_t *msg);

PEP_STATUS update_«@name»_state(PEP_SESSION session, «@name»_t *msg,
        «@name»_PR *fsm, int *message_type);

PEP_STATUS update_«@name»_message(PEP_SESSION session, «@name»_PR fsm,
        int message_type, «@name»_t *msg);

#ifdef __cplusplus
}
#endif

||

template "fsm", mode=state
||
struct _«@name»_state_s {
    int state;

    `` for "func:distinctName(message/field)" |> «func:ctype()» «@name»;
} «yml:lcase(@name)»;
||

template "protocol", mode=impl
    document "generated/{@name}_func.c", "text" {
||
// This file is under GNU General Public License 3.0
// see LICENSE.txt

#include <assert.h>
#include <stdlib.h>
#include "pEp_internal.h"
#include "map_asn1.h"
#include "«@name»_func.h"

void free_«@name»_state(PEP_SESSION session)
{
    if (!session)
        return;

    free_identity(session->«yml:lcase(@name)»_state.basic.from);
    session->«yml:lcase(@name)»_state.basic.from = NULL;

||
for "fsm"
    for "func:distinctName(message/field[not(func:basicType())])"
        |> ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_«@type», &session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»);
|
for "func:distinctName(fsm/message/field[@type='TID'])"
    |> ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_«@type», &session->own_«yml:lcase(../../../@name)»_state.«@name»);
||
}

«@name»_t *new_«@name»_message(«@name»_PR fsm, int message_type)
{
    assert(fsm && message_type);
    if (!(fsm && message_type))
        return NULL;

    «@name»_t *msg = calloc(sizeof(«@name»_t), 1);
    assert(msg);
    if (!msg)
        return NULL;

    msg->present = fsm;
    switch (fsm) {
        `` apply "fsm", mode=impl
        default:
            free(msg);
            return NULL;
    }

    return msg;
}

void free_«@name»_message(«@name»_t *msg)
{
    ASN_STRUCT_FREE(asn_DEF_«@name», msg);
}

PEP_STATUS update_«@name»_state(PEP_SESSION session, «@name»_t *msg,
        «@name»_PR *fsm, int *message_type)
{
    int result = 0;

    assert(session && msg && fsm && message_type);
    if (!(session && msg && fsm && message_type))
        return PEP_ILLEGAL_VALUE;

    *fsm = 0;
    *message_type = 0;

    switch (msg->present) {
        case «@name»_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "fsm", 2, mode=update_state
        default:
            return PEP_ILLEGAL_VALUE;
    }

    *fsm = msg->present;
    return PEP_STATUS_OK;
}

PEP_STATUS update_«@name»_message(PEP_SESSION session, «@name»_PR fsm,
        int message_type, «@name»_t *msg)
{
    int result = 0;

    assert(session && msg);
    if (!(session && msg))
        return PEP_ILLEGAL_VALUE;

    switch (fsm) {
        case «@name»_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "fsm", 2, mode=update_message
        default:
            return PEP_ILLEGAL_VALUE;
    }

    return PEP_STATUS_OK;
}

||
}

template "fsm", mode=update_message
||
case «../@name»_PR_«yml:lcase(@name)»:
    switch (message_type) {
        case «@name»__payload_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "message", 2, mode=update_message
        default:
            return PEP_ILLEGAL_VALUE;
    }
    break;

||

template "message", mode=update_message {
    const "message_name", "concat(yml:lcase(substring(@name,1,1)), substring(@name,2))";
    ||
    case «../@name»__payload_PR_«$message_name»:
        `` apply "field", mode=update_message with "message_name", "$message_name"
        break;

    ||
}

template "field", mode=update_message {
    param "message_name";
    choose {
        when "func:basicType()" // copyable
        ||
        msg->choice.«yml:lcase(../../@name)».payload.choice.«$message_name».«@name»
                 = session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»;

        ||
        when "@type='IdentityList'"
        ||
        {
            identity_list *il = IdentityList_to_identity_list(
                    &session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name», NULL);
            if (!il)
                return PEP_OUT_OF_MEMORY;
            IdentityList_t *_il = IdentityList_from_identity_list(il,
                    &msg->choice.«yml:lcase(../../@name)».payload.choice.«$message_name».«@name»);
            free_identity_list(il);
            if (!_il)
                return PEP_OUT_OF_MEMORY;
        }

        ||
        otherwise // string based
        ||
        result = OCTET_STRING_fromBuf(&msg->choice.«yml:lcase(../../@name)».payload.choice.«$message_name».«@name»,
                (char *) session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name».buf,
                session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name».size);
        if (result)
            return PEP_OUT_OF_MEMORY;

        ||
    }
}

template "fsm", mode=update_state
||
case «../@name»_PR_«yml:lcase(@name)»:
    switch (msg->choice.«yml:lcase(@name)».payload.present) {
        case «@name»__payload_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "message", 2, mode=update_state
        default:
            return PEP_ILLEGAL_VALUE;
    }
    *message_type = msg->choice.«yml:lcase(@name)».payload.present;
    break;

||

template "message", mode=update_state {
    const "message_name", "concat(yml:lcase(substring(@name,1,1)), substring(@name,2))";
    ||
    case «../@name»__payload_PR_«$message_name»:
        `` apply "field", mode=update_state with "message_name", "$message_name"
        break;

    ||
}

template "field", mode=update_state {
    param "message_name";
    choose {
        when "func:basicType()" // copyable
        ||
        session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name» = msg->choice.«yml:lcase(../../@name)»
                .payload.choice.«$message_name».«@name»;

        ||
        when "@type='IdentityList'"
        ||
        {
            identity_list *il = IdentityList_to_identity_list(
                    &msg->choice.«yml:lcase(../../@name)».payload.choice.«$message_name».«@name», NULL);
            if (!il)
                return PEP_OUT_OF_MEMORY;
            IdentityList_t *_il = IdentityList_from_identity_list(il,
                    &session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»);
            free_identity_list(il);
            if (!_il)
                return PEP_OUT_OF_MEMORY;
        }

        ||
        otherwise // string based
        ||
        result = OCTET_STRING_fromBuf(&session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»,
                (char *) msg->choice.«yml:lcase(../../@name)».payload.choice.«$message_name».«@name».buf,
                msg->choice.«yml:lcase(../../@name)».payload.choice.«$message_name».«@name».size);
        if (result)
            return PEP_OUT_OF_MEMORY;

        ||
    }
}

template "fsm", mode=impl
||
case «../@name»_PR_«yml:lcase(@name)»:
    msg->choice.«yml:lcase(@name)».payload.present = message_type;
        break;

||

}

