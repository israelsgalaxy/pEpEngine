// This file is under GNU General Public License 3.0
// see LICENSE.txt

// generate message functions

// Copyleft (c) 2017-2019, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {

include standardlib.ysl2
include ./functions.ysl2

template "/" {
    apply "protocol", 0, mode=header;
    apply "protocol", 0, mode=impl;
}

template "protocol", mode=header
    document "generated/{@name}_func.h", "text"
||
// This file is under GNU General Public License 3.0
// see LICENSE.txt

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>

#include "../asn.1/«@name».h"
`` for "func:distinctType(fsm/message/field[not(func:basicType())])" | #include "../asn.1/«@type».h"

// state

struct «@name»_state_s {
    // own state

    struct own_«@name»_state_s {
        stringlist_t *keys;
        identity_list *identities;

        // TIDs we're using ourselves
        `` for "func:distinctName(fsm/message/field[@type='TID'])" |>> «func:ctype()» «@name»;
    } own;

    // state we learned about our communication partner

    struct comm_partner_state_s {
        // transport data we expect
        pEp_identity *from;
        char *signature_fpr;

        // TIDs our comm partner wants to have
        `` for "func:distinctName(fsm/message/field[@type='TID'])" |>> «func:ctype()» «@name»;
    } comm_partner;

    // input buffer for actual transport data coming in

    struct transport_data_s {
        // transport data we got
        pEp_identity *from;
        char *signature_fpr;
    } transport;
    `` apply "fsm", mode=state
};

void free_«@name»_state(PEP_SESSION session);

// functions for protocol «@name»

«@name»_t *new_«@name»_message(«@name»_PR fsm, int message_type);
void free_«@name»_message(«@name»_t *msg);

PEP_STATUS update_«@name»_state(PEP_SESSION session, «@name»_t *msg,
        «@name»_PR *fsm, int *message_type);

PEP_STATUS update_«@name»_message(PEP_SESSION session, «@name»_t *msg);

#ifdef __cplusplus
}
#endif

||

template "fsm", mode=state
||

// input/output buffer for «@name» messages

struct _«@name»_state_s {
    int state;

    `` for "func:distinctName(message/field)" |> «func:ctype()» «@name»;
} «yml:lcase(@name)»;
||

template "protocol", mode=impl
    document "generated/{@name}_func.c", "text" {
||
// This file is under GNU General Public License 3.0
// see LICENSE.txt

#include <assert.h>
#include <stdlib.h>
#include "pEp_internal.h"
#include "map_asn1.h"
#include "«@name»_func.h"
`` for "fsm" | #include "«@name»_fsm.h"

void free_«@name»_state(PEP_SESSION session)
{
    if (!session)
        return;

    // own state

    free_stringlist(session->«yml:lcase(@name)»_state.own.keys);
    session->«yml:lcase(@name)»_state.own.keys = NULL;
    free_identity_list(session->«yml:lcase(@name)»_state.own.identities);
    session->«yml:lcase(@name)»_state.own.identities = NULL;

    // TIDs we're using ourselves
||
    for "func:distinctName(fsm/message/field[@type='TID'])"
        |> ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_«@type», &session->«yml:lcase(../../../@name)»_state.own.«@name»);
||

    // state we learned about our communication partner

    free_identity(session->«yml:lcase(@name)»_state.comm_partner.from);
    session->«yml:lcase(@name)»_state.comm_partner.from = NULL;
    free(session->«yml:lcase(@name)»_state.comm_partner.signature_fpr);
    session->«yml:lcase(@name)»_state.comm_partner.signature_fpr = NULL;

    // TIDs our comm partner wants to have
||
    for "func:distinctName(fsm/message/field[@type='TID'])"
        |> ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_«@type», &session->«yml:lcase(../../../@name)»_state.comm_partner.«@name»);
||

    // buffer for transport data

    free_identity(session->«yml:lcase(@name)»_state.transport.from);
    session->«yml:lcase(@name)»_state.transport.from = NULL;
    free(session->«yml:lcase(@name)»_state.transport.signature_fpr);
    session->«yml:lcase(@name)»_state.transport.signature_fpr = NULL;

    // message buffers

||
    for "fsm" {
        for "func:distinctName(message/field[not(substring(@type,1,1)=yml:lcase(substring(@type,1,1)))])"
            |> ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_«@type», &session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»);
        |
    }
||
    memset(&session->«yml:lcase(@name)»_state, 0, sizeof(session->«yml:lcase(@name)»_state));
}

«@name»_t *new_«@name»_message(«@name»_PR fsm, int message_type)
{
    «@name»_t *msg = calloc(sizeof(«@name»_t), 1);
    assert(msg);
    if (!msg)
        return NULL;

    if (fsm) {
        msg->present = fsm;
        if (message_type) {
            switch (fsm) {
                `` apply "fsm", 4, mode=impl
                default:
                    free(msg);
                    return NULL;
            }
        }
    }

    return msg;
}

void free_«@name»_message(«@name»_t *msg)
{
    ASN_STRUCT_FREE(asn_DEF_«@name», msg);
}

PEP_STATUS update_«@name»_state(PEP_SESSION session, «@name»_t *msg,
        «@name»_PR *fsm, int *message_type)
{
    int result = 0;

    assert(session && msg && fsm && message_type);
    if (!(session && msg && fsm && message_type))
        return PEP_ILLEGAL_VALUE;

    *fsm = 0;
    *message_type = None;

    switch (msg->present) {
        case «@name»_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "fsm", 2, mode=update_state
        default:
            return PEP_ILLEGAL_VALUE;
    }

    *fsm = msg->present;
    return PEP_STATUS_OK;
}

PEP_STATUS update_«@name»_message(PEP_SESSION session, «@name»_t *msg)
{
    assert(session && msg);
    if (!(session && msg))
        return PEP_ILLEGAL_VALUE;

    int fsm = msg->present;
    switch (fsm) {
        case «@name»_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "fsm", 2, mode=update_message
        default:
            return PEP_ILLEGAL_VALUE;
    }

    return PEP_STATUS_OK;
}

||
}

template "fsm", mode=update_message
||
case «../@name»_PR_«yml:lcase(@name)»:
    {
        int message_type = msg->choice.«yml:lcase(@name)».present;
        switch (message_type) {
            case «@name»_PR_NOTHING:
                return PEP_ILLEGAL_VALUE;

            `` apply "message", 2, mode=update_message
            default:
                return PEP_ILLEGAL_VALUE;
        }
        break;
    }
||

template "message", mode=update_message {
    ||
    case «../@name»_PR_«yml:mixedCase(@name)»:
        `` apply "auto"
        `` apply "field", mode=update_message
        break;

    ||
}

template "auto" choose {
    when "@type = 'Version'" {
        const "fsm", "ancestor::fsm";
        ||
        {
            long *major = (long *) malloc(sizeof(long));
            long *minor = (long *) malloc(sizeof(long));
            assert(major && minor);
            if (!(major && minor))
                return PEP_OUT_OF_MEMORY;

            *major = «$fsm/version/@major»;
            *minor = «$fsm/version/@minor»;

            msg->choice.«yml:lcase($fsm/@name)».choice.«yml:mixedCase(../@name)».«@name».major = major;
            msg->choice.«yml:lcase($fsm/@name)».choice.«yml:mixedCase(../@name)».«@name».minor = minor;
        }

        ||
    }

    otherwise
        error "unkown type for auto in message: {@type}; allowed types: Version";
}

template "field", mode=update_message {
    const "message_name", "yml:mixedCase(../@name)";
    const "state" choose {
        when "@type='TID'"
            > «yml:lcase(ancestor::protocol/@name)»_state.own
        otherwise
            > «yml:lcase(ancestor::protocol/@name)»_state.«yml:lcase(ancestor::fsm/@name)»
    }

    choose {
        when "func:basicType()" // copyable
        ||
        msg->choice.«yml:lcase(../../@name)».choice.«$message_name».«@name»
                 = session->«$state».«@name»;

        ||
        when "@type='IdentityList'"
        ||
        {
            identity_list *il = IdentityList_to_identity_list(
                    &session->«$state».«@name», NULL);
            if (!il)
                return PEP_OUT_OF_MEMORY;
            IdentityList_t *_il = IdentityList_from_identity_list(il,
                    &msg->choice.«yml:lcase(../../@name)».choice.«$message_name».«@name»);
            free_identity_list(il);
            if (!_il)
                return PEP_OUT_OF_MEMORY;
        }

        ||
        otherwise // string based
        ||
        {
            int result = OCTET_STRING_fromBuf(
                    &msg->choice.«yml:lcase(../../@name)».choice.«$message_name».«@name»,
                    (char *) session->«$state».«@name».buf,
                    session->«$state».«@name».size
                );
            if (result)
                return PEP_OUT_OF_MEMORY;
        }
        ||
    }
}

template "fsm", mode=update_state
||
case «../@name»_PR_«yml:lcase(@name)»:
    switch (msg->choice.«yml:lcase(@name)».present) {
        case «@name»_PR_NOTHING:
            return PEP_ILLEGAL_VALUE;

        `` apply "message", 2, mode=update_state
        default:
            return PEP_ILLEGAL_VALUE;
    }
    break;

||

template "message", mode=update_state {
    const "message_name", "concat(yml:lcase(substring(@name,1,1)), substring(@name,2))";
    ||
    case «../@name»_PR_«$message_name»:
        `` apply "field", mode=update_state with "message_name", "$message_name"
        *message_type = «yml:capit($message_name)»;
        break;

    ||
}

template "field", mode=update_state {
    param "message_name";
    choose {
        when "func:basicType()" // copyable
        ||
        session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name» = msg->choice.«yml:lcase(../../@name)»
                .choice.«$message_name».«@name»;

        ||
        when "@type='IdentityList'"
        ||
        {
            identity_list *il = IdentityList_to_identity_list(
                    &msg->choice.«yml:lcase(../../@name)».choice.«$message_name».«@name», NULL);
            if (!il)
                return PEP_OUT_OF_MEMORY;
            IdentityList_t *_il = IdentityList_from_identity_list(il,
                    &session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»);
            free_identity_list(il);
            if (!_il)
                return PEP_OUT_OF_MEMORY;
        }

        ||
        otherwise // string based
        ||
        result = OCTET_STRING_fromBuf(&session->«yml:lcase(../../../@name)»_state.«yml:lcase(../../@name)».«@name»,
                (char *) msg->choice.«yml:lcase(../../@name)».choice.«$message_name».«@name».buf,
                msg->choice.«yml:lcase(../../@name)».choice.«$message_name».«@name».size);
        if (result)
            return PEP_OUT_OF_MEMORY;

        ||
    }
}

template "fsm", mode=impl
||
case «../@name»_PR_«yml:lcase(@name)»:
    msg->choice.«yml:lcase(@name)».present = message_type;
        break;

||

}

