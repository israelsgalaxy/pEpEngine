// This file is under GNU General Public License 3.0
// see LICENSE.txt

// generate conditions and actions

// Copyleft (c) 2017-2019, p≡p foundation

// Written by Volker Birk


include ./sql_func.yml2

// condition: PEP_STATUS «@name»(PEP_SESSION session, bool *result)

condition deviceGrouped {
    call "exec_sql_int" with "sql"
        > "select count(*) from identity where is_own = 1 and (flags & 0x100) = 0x100;"
    |> *result = _result > 0;
}

condition weAreFirst
||
    TID_t *t1 = &session->sync_state.keysync.challenge;
    TID_t *t2 = &session->sync_state.own.challenge;

    *result = _TID_greater(t1, t2);
||

condition partnerIsGrouped
|> *result = session->sync_state.keysync.is_group;

condition challengeAccepted
||
    TID_t *t1 = &session->sync_state.keysync.challenge;
    TID_t *t2 = &session->sync_state.own.challenge;

    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0;
||

condition sameChallenge
||
    TID_t *t1 = &session->sync_state.keysync.challenge;
    TID_t *t2 = &session->sync_state.own.challenge;

    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0;
||

condition sameTransaction
||
    TID_t *t1 = &session->sync_state.keysync.negotiation;
    TID_t *t2 = &session->sync_state.own.negotiation;

    // test if TID is identical
    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0;
||

condition sameTransactionAndPartner
||
    TID_t *t1 = &session->sync_state.keysync.negotiation;
    TID_t *t2 = &session->sync_state.own.negotiation;

    const char *s1 = session->sync_state.comm_partner.signature_fpr;
    const char *s2 = session->sync_state.transport.signature_fpr;

    // test if TID is identical
    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0
    // and test if we're talking to the same sender
            && s1 && s2 && strcmp(s1, s2) == 0;
||

condition keyElectionWon
||
    pEp_identity *from = session->sync_state.comm_partner.from;
    char *signature_fpr = session->sync_state.comm_partner.signature_fpr;

    assert(from && from->address && from->address[0] && from->user_id &&
            from->user_id[0]);
    if (!(from && from->address && from->address[0] && from->user_id &&
            from->user_id[0]))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *me = NULL;
    PEP_STATUS status = get_identity(session, from->address, from->user_id, &me);
    assert(status == PEP_STATUS_OK);
    if (status)
        return status;

    assert(me->fpr && me->fpr[0]);
    if (!(me->fpr && me->fpr[0])) {
        free_identity(me);
        return PEP_ILLEGAL_VALUE;
    }

    size_t len = MIN(strlen(signature_fpr), strlen(me->fpr));
    *result = strncasecmp(signature_fpr, me->fpr, len) > 0;
    free_identity(me);
||

// action: PEP_STATUS «@name»(PEP_SESSION session)

function "new_UUID" {
    param "dst";
    ||
        pEpUUID c;
        uuid_generate_random(c);

        OCTET_STRING_fromBuf(«$dst», (char *) c, 16);
    ||
}

function "copy_UUID" {
    param "src", param "dst";
    ||
        {
            TID_t *src = «$src»;
            TID_t *dst = «$dst»;

            assert(src->size == 16);
            if (!(src->size == 16))
                return PEP_UNKNOWN_ERROR;

            OCTET_STRING_fromBuf(dst, (char *) src->buf, src->size);
        }
    ||
}

function "xor_UUID" {
    param "src", param "dst";
    ||
        {
            TID_t *src = «$src»;
            TID_t *dst = «$dst»;

            assert(src->size == 16 && dst->size == 16);
            if (!(src->size == 16 && dst->size == 16))
                return PEP_UNKNOWN_ERROR;

            for (int i=0; i < src->size; ++i)
                dst->buf[i] ^= src->buf[i];
        }
    ||
}

action newChallenge {
    // random new challenge
    call "new_UUID" with "dst" > &session->sync_state.own.challenge
}

action replyChallenge call "copy_UUID" {
    with "src" > &session->sync_state.keysync.challenge
    with "dst" > &session->sync_state.comm_partner.challenge
}

action useOwnChallenge call "copy_UUID" {
    with "src" > &session->sync_state.own.challenge
    with "dst" > &session->sync_state.keysync.challenge
}

action newNegotiation {
||
    // sender key must be stable while transaction

    // we take the actual signature of the last message and store it in our
    // state for the comm partner
    assert(session->sync_state.transport.signature_fpr);

    free(session->sync_state.comm_partner.signature_fpr);

    session->sync_state.comm_partner.signature_fpr
            = strdup(session->sync_state.transport.signature_fpr);
    assert(session->sync_state.comm_partner.signature_fpr);
    if (!session->sync_state.comm_partner.signature_fpr)
        return PEP_OUT_OF_MEMORY;

||
    call "copy_UUID" {
        with "src" > &session->sync_state.keysync.challenge
        with "dst" > &session->sync_state.keysync.negotiation
    }
    call "xor_UUID" {
        with "src" > &session->sync_state.own.challenge
        with "dst" > &session->sync_state.keysync.negotiation
    }
    call "copy_UUID" {
        with "src" > &session->sync_state.keysync.negotiation
        with "dst" > &session->sync_state.own.negotiation
    }
}

action closeTransaction
||
    memset(session->sync_state.keysync.negotiation.buf, 0,
            session->sync_state.keysync.negotiation.size);
    memset(session->sync_state.own.negotiation.buf, 0,
            session->sync_state.own.negotiation.size);
||

action storeTransaction {
||
    // sender key must be stable while transaction

    // we take the actual signature of the last message and store it in our
    // state for the comm partner
    assert(session->sync_state.transport.signature_fpr);

    free(session->sync_state.comm_partner.signature_fpr);

    session->sync_state.comm_partner.signature_fpr
            = strdup(session->sync_state.transport.signature_fpr);
    assert(session->sync_state.comm_partner.signature_fpr);
    if (!session->sync_state.comm_partner.signature_fpr)
        return PEP_OUT_OF_MEMORY;

||
    call "copy_UUID" {
        with "src" > &session->sync_state.keysync.negotiation
        with "dst" > &session->sync_state.own.negotiation
    }
}

function "show_handshake" {
    param "type";
    ||
        assert(session->notifyHandshake);
        if (!session->notifyHandshake)
            return PEP_SYNC_NO_NOTIFY_CALLBACK;
     
    ||
    choose {
    when "$type = 'SYNC_NOTIFY_TIMEOUT' or $type = 'SYNC_NOTIFY_SOLE' or $type = 'SYNC_NOTIFY_IN_GROUP'"
    ||
        pEp_identity *me = new_identity(NULL, NULL, NULL, NULL);
        pEp_identity *partner = new_identity(NULL, NULL, NULL, NULL);
        assert(me && partner);
        if (!(me && partner)) {
            free_identity(me);
            free_identity(partner);
            return PEP_OUT_OF_MEMORY;
        }

        PEP_STATUS status = session->notifyHandshake(me, partner, «$type»);
        if (status)
            return status;
    ||
    otherwise
    ||
        assert(session->sync_state.comm_partner.from);
        if (!session->sync_state.comm_partner.from)
            return PEP_ILLEGAL_VALUE;

        pEp_identity *from = session->sync_state.comm_partner.from;
        pEp_identity *me = NULL;
        PEP_STATUS status = get_identity(session, from->address, from->user_id, &me);
        assert(status == PEP_STATUS_OK);
        if (status)
            return status;

        assert(me->fpr && me->fpr[0]);
        if (!(me->fpr && me->fpr[0])) {
            free_identity(me);
            return PEP_ILLEGAL_VALUE;
        }

        pEp_identity *partner = identity_dup(from);
        if (!partner) {
            free_identity(me);
            return PEP_OUT_OF_MEMORY;
        }

        assert(session->sync_state.comm_partner.signature_fpr);
        if (session->sync_state.comm_partner.signature_fpr) {
            free(partner->fpr);
            partner->fpr = strdup(session->sync_state.comm_partner.signature_fpr);
            if (!partner->fpr) {
                free_identity(me);
                free_identity(partner);
                return PEP_OUT_OF_MEMORY;
            }
        }

        free(partner->user_id);
        partner->user_id = strdup("#NV");
        assert(partner->user_id);
        if (!partner->user_id) {
            free_identity(me);
            free_identity(partner);
            return PEP_OUT_OF_MEMORY;
        }

        status = session->notifyHandshake(me, partner, «$type»);
        if (status)
            return status;
    ||
    }
}

action showSoleHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_FORM_GROUP

action showJoinGroupHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_ADD_OUR_DEVICE

action showGroupedHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_ADD_OTHER_DEVICE

action hideHandshakeDialog
    call "show_handshake" with "type" > SYNC_NOTIFY_OVERTAKEN

action showDeviceAdded
    call "show_handshake" with "type" > SYNC_NOTIFY_ACCEPTED_DEVICE_ADDED

action showGroupCreated
    call "show_handshake" with "type" > SYNC_NOTIFY_ACCEPTED_GROUP_CREATED

action showBeingSole
    call "show_handshake" with "type" > SYNC_NOTIFY_SOLE

action showBeingInGroup
    call "show_handshake" with "type" > SYNC_NOTIFY_IN_GROUP

timeout KeySync
    call "show_handshake" with "type" > SYNC_NOTIFY_TIMEOUT

action prepareOwnKeys
||
    stringlist_t *own_keys;
    PEP_STATUS status = _own_keys_retrieve(session, &own_keys, PEP_idf_not_for_sync, true);
    if (status)
        return status;

    if (session->sync_state.own.keys)
        free_stringlist(session->sync_state.own.keys);
    session->sync_state.own.keys = own_keys;

    identity_list *il;
    status = _own_identities_retrieve(session, &il, PEP_idf_not_for_sync);
    if (status)
        return status;

    IdentityList_from_identity_list(il, &session->sync_state.keysync.ownIdentities);
    free_identity_list(il);
||

action saveGroupKeys
||
    identity_list *il = IdentityList_to_identity_list(&session->sync_state.keysync.ownIdentities, NULL);
    if (!il)
        return PEP_OUT_OF_MEMORY;
    
    // BUG: this should be a transaction and been rolled back completely on error
    for (identity_list *_il = il; _il && _il->ident; _il = _il->next) {
        PEP_STATUS status = set_identity(session, _il->ident);
        if (status) {
            free_identity_list(il);
            return status;
        }
    }

    free_identity_list(il);
||

action ownKeysAreGroupKeys
||
    PEP_STATUS status = PEP_STATUS_OK;

    // set flag for current keys
    for (identity_list *il = session->sync_state.own.identities; il && il->ident ; il = il->next) {
        if (!(il->ident->flags && PEP_idf_not_for_sync)) {
            status = set_identity_flags(session, il->ident, PEP_idf_devicegroup);
            if (status)
                return status;
        }
    }
||

action receivedKeysAreGroupKeys
||
    PEP_STATUS status = PEP_STATUS_OK;

    // set flag for current keys
    for (identity_list *il = session->sync_state.own.identities; il && il->ident ; il = il->next) {
        if (!(il->ident->flags && PEP_idf_not_for_sync)) {
            status = set_identity_flags(session, il->ident, PEP_idf_devicegroup);
            if (status)
                return status;
        }
    }

    identity_list *il = IdentityList_to_identity_list(&session->sync_state.keysync.ownIdentities, NULL);
    if (!il)
        return PEP_OUT_OF_MEMORY;

    for (il = session->sync_state.own.identities; il && il->ident ; il = il->next) {
        // replace partner's user_id with own user_id
        free(il->ident->user_id);
        il->ident->user_id = strdup(session->sync_state.comm_partner.from->user_id);
        if (!il->ident->user_id) {
            free_identity_list(il);
            return PEP_OUT_OF_MEMORY;
        }

        status = myself(session, il->ident);
        if (status) {
            free_identity_list(il);
            return status;
        }

        status = set_identity_flags(session, il->ident, PEP_idf_devicegroup);
        if (status) {
            free_identity_list(il);
            return status;
        }
    }

    free_identity_list(il);
||

action trustThisKey
||
    assert(session->sync_state.comm_partner.from && session->sync_state.comm_partner.signature_fpr);
    if (!(session->sync_state.comm_partner.from && session->sync_state.comm_partner.signature_fpr))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *ident = identity_dup(session->sync_state.comm_partner.from);
    if (!ident)
        return PEP_OUT_OF_MEMORY;
    free(ident->fpr);
    ident->fpr = strdup(session->sync_state.comm_partner.signature_fpr);
    assert(ident->fpr);
    if (!ident->fpr) {
        free_identity(ident);
        return PEP_OUT_OF_MEMORY;
    }

    PEP_STATUS status = trust_own_key(session, ident);
    if (status) {
        free_identity(ident);
        return status;
    }

    OCTET_STRING_fromBuf(&session->sync_state.keysync.key, ident->fpr, strlen(ident->fpr));
    free_identity(ident);
||

action untrustThisKey
||
    assert(session->sync_state.comm_partner.from && session->sync_state.comm_partner.signature_fpr);
    if (!(session->sync_state.comm_partner.from && session->sync_state.comm_partner.signature_fpr))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *ident = session->sync_state.comm_partner.from;
    free(ident->fpr);
    ident->fpr = strdup(session->sync_state.comm_partner.signature_fpr);
    assert(ident->fpr);
    if (!ident->fpr)
        return PEP_OUT_OF_MEMORY;

    PEP_STATUS status = key_reset_trust(session, ident);
    if (status)
        return status;

    OCTET_STRING_fromBuf(&session->sync_state.keysync.key, "", 0);
||

action tellWeAreGrouped
||
    session->sync_state.keysync.is_group = true;
||

action tellWeAreNotGrouped
||
    session->sync_state.keysync.is_group = false;
||

action disable;

