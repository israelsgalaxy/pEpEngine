// This file is under GNU General Public License 3.0
// see LICENSE.txt

// generate conditions and actions

// Copyleft (c) 2017-2019, p≡p foundation

// Written by Volker Birk


include ./sql_func.yml2

// condition: PEP_STATUS «@name»(PEP_SESSION session, bool *result)

condition deviceGrouped {
    call "exec_sql_int" with "sql"
        > "select count(*) from identity where is_own = 1 and (flags & 0x100) = 0x100;"
    |> *result = _result > 0;
}

condition weAreOfferer
||
    TID_t *t1 = &session->sync_state.keysync.challenge;
    TID_t *t2 = &session->sync_state.own.challenge;

    *result = _TID_greater(t1, t2);
||

condition partnerIsGrouped
|> *result = session->sync_state.keysync.is_group;

condition sameChallenge
||
    TID_t *t1 = &session->sync_state.keysync.challenge;
    TID_t *t2 = &session->sync_state.own.challenge;

    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0;
||

condition sameNegotiation
||
    TID_t *t1 = &session->sync_state.keysync.negotiation;
    TID_t *t2 = &session->sync_state.comm_partner.negotiation;

    // test if TID is identical
    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0;
||

condition sameNegotiationAndPartner
||
    TID_t *t1 = &session->sync_state.keysync.negotiation;
    TID_t *t2 = &session->sync_state.comm_partner.negotiation;

    const char *s1 = session->sync_state.comm_partner.sender_fpr;
    const char *s2 = session->sync_state.transport.sender_fpr;

    // test if TID is identical
    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0
    // and test if we're talking to the same sender
            && s1 && s2 && strcmp(s1, s2) == 0;
||

condition keyElectionWon
||
    pEp_identity *from = session->sync_state.transport.from;
    char *sender_fpr = session->sync_state.comm_partner.sender_fpr;

    assert(from && from->address && from->address[0] && from->user_id &&
            from->user_id[0]);
    if (!(from && from->address && from->address[0] && from->user_id &&
            from->user_id[0]))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *me = NULL;
    PEP_STATUS status = get_identity(session, from->address, from->user_id, &me);
    assert(status == PEP_STATUS_OK);
    if (status)
        return status;

    assert(me->fpr && me->fpr[0]);
    if (!(me->fpr && me->fpr[0])) {
        free_identity(me);
        return PEP_ILLEGAL_VALUE;
    }

    size_t len = MIN(strlen(sender_fpr), strlen(me->fpr));
    *result = strncasecmp(sender_fpr, me->fpr, len) > 0;
    free_identity(me);
||

// action: PEP_STATUS «@name»(PEP_SESSION session)

function "new_UUID" {
    param "dst";
    ||
        {
            pEpUUID c;
            uuid_generate_random(c);

            OCTET_STRING_fromBuf(«$dst», (char *) c, 16);
        }
    ||
}

function "copy_UUID" {
    param "src", param "dst";
    ||
        {
            TID_t *src = «$src»;
            TID_t *dst = «$dst»;

            assert(src->size == 16);
            if (!(src->size == 16))
                return PEP_UNKNOWN_ERROR;

            OCTET_STRING_fromBuf(dst, (char *) src->buf, src->size);
        }
    ||
}

function "xor_UUID" {
    param "src", param "dst";
    ||
        {
            TID_t *src = «$src»;
            TID_t *dst = «$dst»;

            assert(src->size == 16 && dst->size == 16);
            if (!(src->size == 16 && dst->size == 16))
                return PEP_UNKNOWN_ERROR;

            for (int i=0; i < src->size; ++i)
                dst->buf[i] ^= src->buf[i];
        }
    ||
}

action newChallengeAndNegotiationBase {
    // random new challenge
    call "new_UUID" with "dst" > &session->sync_state.own.challenge
    call "copy_UUID" {
        with "src" > &session->sync_state.own.challenge
        with "dst" > &session->sync_state.keysync.challenge
    }

    // this is the random data we are using as a base
    call "new_UUID" with "dst" > &session->sync_state.own.negotiation
||
    memset(session->sync_state.keysync.negotiation.buf, 0,
            session->sync_state.keysync.negotiation.size);
    memset(session->sync_state.comm_partner.negotiation.buf, 0,
            session->sync_state.comm_partner.negotiation.size);
||
}

action useOwnChallenge call "copy_UUID" {
    with "src" > &session->sync_state.own.challenge
    with "dst" > &session->sync_state.keysync.challenge
}

action openNegotiation {
||
    // sender key must be stable while transaction

    // we take the actual signature of the last message and store it in our
    // state for the comm partner
    assert(session->sync_state.transport.sender_fpr);

    free(session->sync_state.comm_partner.sender_fpr);

    session->sync_state.comm_partner.sender_fpr
            = strdup(session->sync_state.transport.sender_fpr);
    assert(session->sync_state.comm_partner.sender_fpr);
    if (!session->sync_state.comm_partner.sender_fpr)
        return PEP_OUT_OF_MEMORY;

    // we need a unique TID for the Negotiation with each single comm_partner
    // we identify the comm_partners by their Challenge
    // we derive the actual Negotiation TID by having random data and XORing it
    // with comm_partner's Challenge

    // copy Negotiation base into buffer

||
    call "copy_UUID" {
        with "src" > &session->sync_state.own.negotiation
        with "dst" > &session->sync_state.keysync.negotiation
    }
||

    // we're XORing this with the challenge of the comm_partner, which is in
    // the buffer already

||
    call "xor_UUID" {
        with "src" > &session->sync_state.keysync.challenge
        with "dst" > &session->sync_state.keysync.negotiation
    }
||

    // this is the Negotiation's TID for this comm_partner

||
    call "copy_UUID" {
        with "src" > &session->sync_state.keysync.negotiation
        with "dst" > &session->sync_state.comm_partner.negotiation
    }
}

action storeNegotiation {
||
    // sender key must be stable while transaction

    // we take the actual signature of the last message and store it in our
    // state for the comm partner
    assert(session->sync_state.transport.sender_fpr);

    free(session->sync_state.comm_partner.sender_fpr);

    session->sync_state.comm_partner.sender_fpr
            = strdup(session->sync_state.transport.sender_fpr);
    assert(session->sync_state.comm_partner.sender_fpr);
    if (!session->sync_state.comm_partner.sender_fpr)
        return PEP_OUT_OF_MEMORY;

||
    call "copy_UUID" {
        with "src" > &session->sync_state.keysync.negotiation
        with "dst" > &session->sync_state.comm_partner.negotiation
    }
}

function "show_handshake" {
    param "type";
    ||
        assert(session->notifyHandshake);
        if (!session->notifyHandshake)
            return PEP_SYNC_NO_NOTIFY_CALLBACK;
     
    ||
    choose {
    when "$type = 'SYNC_NOTIFY_INIT_ADD_OUR_DEVICE' or $type = 'SYNC_NOTIFY_INIT_ADD_OTHER_DEVICE' or $type = 'SYNC_NOTIFY_INIT_FORM_GROUP'"
    ||
        assert(session->sync_state.transport.from);
        if (!session->sync_state.transport.from)
            return PEP_ILLEGAL_VALUE;

        pEp_identity *from = session->sync_state.transport.from;
        pEp_identity *me = NULL;
        PEP_STATUS status = get_identity(session, from->address, from->user_id, &me);
        assert(status == PEP_STATUS_OK);
        if (status)
            return status;
        assert(strcmp(me->fpr, session->sync_state.comm_partner.sender_fpr) != 0);
        
        assert(me->fpr && me->fpr[0]);
        if (!(me->fpr && me->fpr[0])) {
            free_identity(me);
            return PEP_ILLEGAL_VALUE;
        }

        pEp_identity *partner = identity_dup(from);
        if (!partner) {
            free_identity(me);
            return PEP_OUT_OF_MEMORY;
        }

        assert(session->sync_state.comm_partner.sender_fpr);
        if (session->sync_state.comm_partner.sender_fpr) {
            free(partner->fpr);
            partner->fpr = strdup(session->sync_state.comm_partner.sender_fpr);
            assert(partner->fpr);
            if (!partner->fpr) {
                free_identity(me);
                free_identity(partner);
                return PEP_OUT_OF_MEMORY;
            }
        }

        free(partner->user_id);
        partner->user_id = strdup("#NV");
        assert(partner->user_id);
        if (!partner->user_id) {
            free_identity(me);
            free_identity(partner);
            return PEP_OUT_OF_MEMORY;
        }

        assert(strcmp(me->fpr, partner->fpr) != 0);
        status = session->notifyHandshake(me, partner, «$type»);
        if (status)
            return status;
    ||
    otherwise
    ||
        pEp_identity *me = new_identity(NULL, NULL, NULL, NULL);
        pEp_identity *partner = new_identity(NULL, NULL, NULL, NULL);
        assert(me && partner);
        if (!(me && partner)) {
            free_identity(me);
            free_identity(partner);
            return PEP_OUT_OF_MEMORY;
        }

        PEP_STATUS status = session->notifyHandshake(me, partner, «$type»);
        if (status)
            return status;
    ||
    }
}

action showSoleHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_FORM_GROUP

action showJoinGroupHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_ADD_OUR_DEVICE

action showGroupedHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_ADD_OTHER_DEVICE

action hideHandshakeDialog
    call "show_handshake" with "type" > SYNC_NOTIFY_OVERTAKEN

action showDeviceAdded
    call "show_handshake" with "type" > SYNC_NOTIFY_ACCEPTED_DEVICE_ADDED

action showFormingGroup
    call "show_handshake" with "type" > SYNC_NOTIFY_FORMING_GROUP
    
action showGroupCreated
    call "show_handshake" with "type" > SYNC_NOTIFY_ACCEPTED_GROUP_CREATED

action showBeingSole
    call "show_handshake" with "type" > SYNC_NOTIFY_SOLE

action showBeingInGroup
    call "show_handshake" with "type" > SYNC_NOTIFY_IN_GROUP

timeout KeySync
    call "show_handshake" with "type" > SYNC_NOTIFY_TIMEOUT

action prepareOwnKeys
||
    stringlist_t *own_keys;
    PEP_STATUS status = _own_keys_retrieve(session, &own_keys, PEP_idf_not_for_sync, true);
    if (status)
        return status;

    if (session->sync_state.own.keys)
        free_stringlist(session->sync_state.own.keys);
    session->sync_state.own.keys = own_keys;

    identity_list *il;
    status = _own_identities_retrieve(session, &il, PEP_idf_not_for_sync);
    if (status)
        return status;

    IdentityList_from_identity_list(il, &session->sync_state.keysync.ownIdentities);
    free_identity_list(il);
||

action saveGroupKeys
||
    char *user_id = NULL;
    PEP_STATUS status = get_default_own_userid(session, &user_id);
    if (status)
        return status;

    identity_list *il = IdentityList_to_identity_list(&session->sync_state.keysync.ownIdentities, NULL);
    if (!il) {
        free(user_id);
        return PEP_OUT_OF_MEMORY;
    }
    
    identity_list *oil = session->sync_state.own.identities;

    // BUG: this should be a transaction and been rolled back completely on error
    for (identity_list *_il = il; _il && _il->ident; _il = _il->next) {
        pEp_identity *ident = _il->ident;
        bool is_own_already = false;

        status = is_own_address(session, ident->address, &is_own_already);
        if (status) {
            free_identity_list(il);
            free(user_id);
            return status;
        }

        free(ident->user_id);
        ident->user_id = strdup(user_id);
        assert(ident->user_id);
        if (!ident->user_id) {
            free_identity_list(il);
            free(user_id);
            return PEP_OUT_OF_MEMORY;
        }

        if (is_own_already) {
            ident->comm_type = PEP_ct_pEp;
            status = set_trust(session, ident);
        }
        else {
            oil = identity_list_add(oil, ident);
            if (!oil) {
                free_identity_list(il);
                free(user_id);
                return PEP_OUT_OF_MEMORY;
            }
            status = myself(session, ident);
        }
        if (status) {
            free_identity_list(il);
            free(user_id);
            return status;
        }
    }

    free(user_id);
    free_identity_list(il);
||

action ownKeysAreDefaultKeys
||
    PEP_STATUS status = PEP_STATUS_OK;

    // set flag for all keys; don't change anything else
    for (identity_list *il = session->sync_state.own.identities; il && il->ident ; il = il->next) {
        if (!(il->ident->flags && PEP_idf_not_for_sync)) {
            status = set_identity_flags(session, il->ident, PEP_idf_devicegroup);
            if (status)
                return status;
        }
    }
||

action receivedKeysAreDefaultKeys
||
    PEP_STATUS status = PEP_STATUS_OK;
    // set flag for all keys
    for (identity_list *il = session->sync_state.own.identities; il && il->ident ; il = il->next) {
        if (!(il->ident->flags && PEP_idf_not_for_sync)) {
            
            status = set_identity_flags(session, il->ident, PEP_idf_devicegroup);
            if (status)
                return status;
        }
    }

    char *user_id = NULL;
    status = get_default_own_userid(session, &user_id);
    if (status)
        return status;

    identity_list *il = IdentityList_to_identity_list(&session->sync_state.keysync.ownIdentities, NULL);
    if (!il)
        return PEP_OUT_OF_MEMORY;

    for (identity_list *_il = il; _il && _il->ident ; _il = _il->next) {
        // replace partner's user_id with own user_id
        free(_il->ident->user_id);
        _il->ident->user_id = strdup(user_id);
        assert(_il->ident->user_id);
        if (!_il->ident->user_id) {
            free_identity_list(il);
            free(user_id);
            return PEP_OUT_OF_MEMORY;
        }
    
        const char *own_key = _il->ident->fpr;
        _il->ident->fpr = NULL;
        status = set_own_key(session, _il->ident, own_key);
        if (status) {
            free_identity_list(il);
            free(user_id);
            return status;
        }
    }

    free_identity_list(il);
    free(user_id);
||

action trustThisKey
||
    assert(session->sync_state.transport.from && session->sync_state.comm_partner.sender_fpr);
    if (!(session->sync_state.transport.from && session->sync_state.comm_partner.sender_fpr))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *ident = identity_dup(session->sync_state.transport.from);
    if (!ident)
        return PEP_OUT_OF_MEMORY;
    free(ident->fpr);
    ident->fpr = strdup(session->sync_state.comm_partner.sender_fpr);
    assert(ident->fpr);
    if (!ident->fpr) {
        free_identity(ident);
        return PEP_OUT_OF_MEMORY;
    }

    PEP_STATUS status = trust_own_key(session, ident);
    if (status) {
        free_identity(ident);
        return status;
    }

    OCTET_STRING_fromBuf(&session->sync_state.keysync.key, ident->fpr, strlen(ident->fpr));
    free_identity(ident);
||

action untrustThisKey
||
    assert(session->sync_state.transport.from && session->sync_state.comm_partner.sender_fpr);
    if (!(session->sync_state.transport.from && session->sync_state.comm_partner.sender_fpr))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *ident = session->sync_state.transport.from;
    free(ident->fpr);
    ident->fpr = strdup(session->sync_state.comm_partner.sender_fpr);
    assert(ident->fpr);
    if (!ident->fpr)
        return PEP_OUT_OF_MEMORY;

    PEP_STATUS status = key_reset_trust(session, ident);
    if (status)
        return status;

    OCTET_STRING_fromBuf(&session->sync_state.keysync.key, "", 0);
||

action tellWeAreGrouped
||
    session->sync_state.keysync.is_group = true;
||

action tellWeAreNotGrouped
||
    session->sync_state.keysync.is_group = false;
||

action disable
||
    leave_device_group(session);
    // ignore the result, disable anyway

    if (!session->inject_sync_event)
        return PEP_SYNC_NO_INJECT_CALLBACK;

    session->inject_sync_event((void *) SHUTDOWN, NULL);
||
