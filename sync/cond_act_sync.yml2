// This file is under GNU General Public License 3.0
// see LICENSE.txt

// generate conditions and actions

// Copyleft (c) 2017, 2018, p≡p foundation

// Written by Volker Birk


include ./sql_func.yml2

// condition: PEP_STATUS «@name»(PEP_SESSION session, bool *result)

condition deviceGrouped {
    call "exec_sql_int" with "sql"
        > "select count(*) from identity where is_own = true and (flags & 4) = 4;"
    |> *result = _result > 0;
}

condition partnerIsGrouped
|> *result = session->sync_state.keysync.is_group;

condition challengeAccepted
||
    TID_t *t1 = &session->sync_state.keysync.challenge;
    TID_t *t2 = &session->own_sync_state.challenge;

    *result = t1->size == t2->size && memcmp(t1->buf, t2->buf, t1->size) == 0;
||

condition keyElectionWon
||
    pEp_identity *from = session->sync_state.common.from;

    assert(from && from->fpr && from->fpr[0] && from->address &&
            from->address[0] && from->user_id && from->user_id[0]);
    if (!(from && from->fpr && from->fpr[0] && from->address &&
            from->address[0] && from->user_id && from->user_id[0]))
        return PEP_ILLEGAL_VALUE;

    pEp_identity *me = NULL;
    PEP_STATUS status = get_identity(session, from->address, from->user_id, &me);
    assert(status == PEP_STATUS_OK);
    if (status)
        return status;

    assert(me->fpr && me->fpr[0]);
    if (!(me->fpr && me->fpr[0])) {
        free_identity(me);
        return PEP_ILLEGAL_VALUE;
    }

    size_t len = MIN(strlen(from->fpr), strlen(me->fpr));
    *result = strncasecmp(from->fpr, me->fpr, len) > 0;
    free_identity(me);
||

// action: PEP_STATUS «@name»(PEP_SESSION session)

function "new_UUID" {
    param "dst";
    ||
        pEpUUID c;
        uuid_generate_random(c);

        OCTET_STRING_fromBuf(«$dst», (char *) c, 16);
    ||
}

function "copy_UUID" {
    param "src", param "dst";
    ||
        TID_t *src = «$src»;
        TID_t *dst = «$dst»;

        assert(src->size == 16);
        if (!(src->size == 16))
            return PEP_UNKNOWN_ERROR;

        OCTET_STRING_fromBuf(dst, (char *) src->buf, src->size);
    ||
}

action openChallenge
    call "new_UUID" with "dst" > &session->own_sync_state.challenge

action storeChallenge call "copy_UUID" {
    with "src" > &session->sync_state.keysync.challenge
    with "dst" > &session->own_sync_state.challenge
}

action openTransaction
    call "new_UUID" with "dst" > &session->own_sync_state.transaction

action storeTransaction call "copy_UUID" {
    with "src" > &session->sync_state.keysync.transaction
    with "dst" >  &session->own_sync_state.transaction
}

function "show_handshake" {
    param "type";
    ||
        assert(session->notifyHandshake);
        if (!session->notifyHandshake)
            return PEP_SYNC_NO_NOTIFY_CALLBACK;
     
        assert(session->sync_state.common.from);
        if (!session->sync_state.common.from)
            return PEP_ILLEGAL_VALUE;

        pEp_identity *from = session->sync_state.common.from;
        pEp_identity *me = NULL;
        PEP_STATUS status = get_identity(session, from->address, from->user_id, &me);
        assert(status == PEP_STATUS_OK);
        if (status)
            return status;

        assert(me->fpr && me->fpr[0]);
        if (!(me->fpr && me->fpr[0])) {
            free_identity(me);
            return PEP_ILLEGAL_VALUE;
        }

        pEp_identity *partner = identity_dup(from);
        if (!partner) {
            free_identity(me);
            return PEP_OUT_OF_MEMORY;
        }

        status = session->notifyHandshake(session->sync_management, me,
                partner, «$type»);
        if (status)
            return status;
    ||
}

action showSoleHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_FORM_GROUP

action showJoinGroupHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_ADD_OUR_DEVICE

action showGroupedHandshake
    call "show_handshake" with "type" > SYNC_NOTIFY_INIT_ADD_OTHER_DEVICE

action saveGroupKeys
||
    identity_list *il = IdentityList_to_identity_list(&session->sync_state.keysync.identities, NULL);
    if (!il)
        return PEP_OUT_OF_MEMORY;
    
    // BUG: this should be a transaction and been rolled back completely on error
    for (identity_list *_il = il; _il && _il->ident; _il = _il->next) {
        PEP_STATUS status = set_identity(session, _il->ident);
        if (status) {
            free_identity_list(il);
            return status;
        }
    }

    free_identity_list(il);
||

action ownKeysAreGroupKeys {
    call "init_sql" with "sql" {
        ||
        "select fpr, username, comm_type, lang,"
                "   identity.flags | pgp_keypair.flags"
                "   from identity"
                "   join person on id = identity.user_id"
                "   join pgp_keypair on fpr = identity.main_key_id"
                "   join trust on id = trust.user_id"
                "       and pgp_keypair_fpr = identity.main_key_id"
                "   where identity.is_own = true ;"
        ||
    }

    ||
        identity_list *il = new_identity_list(NULL);
        if (!il)
            return PEP_OUT_OF_MEMORY;

        pEp_identity *from = session->sync_state.common.from;
        identity_list *_il = il;

        int result;
        do {
            result = sqlite3_step(_sql);
            pEp_identity *_identity = NULL;
            switch (result) {
            case SQLITE_ROW:
                _identity = new_identity(
                        from->address,
                        (const char *) sqlite3_column_text(_sql, 0),
                        from->user_id,
                        (const char *) sqlite3_column_text(_sql, 1)
                        );
                assert(_identity);
                if (_identity == NULL)
                    return PEP_OUT_OF_MEMORY;

                _identity->comm_type = (PEP_comm_type)
                    sqlite3_column_int(_sql, 2);
                const char* const _lang = (const char *)
                    sqlite3_column_text(_sql, 3);
                if (_lang && _lang[0]) {
                    assert(_lang[0] >= 'a' && _lang[0] <= 'z');
                    assert(_lang[1] >= 'a' && _lang[1] <= 'z');
                    assert(_lang[2] == 0);
                    _identity->lang[0] = _lang[0];
                    _identity->lang[1] = _lang[1];
                    _identity->lang[2] = 0;
                }
                _identity->flags = (unsigned int)
                    sqlite3_column_int(_sql, 4);

                _il = identity_list_add(_il, _identity);
                if (!_il) {
                    free_identity_list(il);
                    free_identity(_identity);
                    return PEP_OUT_OF_MEMORY;
                }
                break;

            case SQLITE_DONE:
                break;

            default:
                free_identity_list(il);
                return PEP_UNKNOWN_ERROR;
            }
        } while (result != SQLITE_DONE);

        IdentityList_t *r = IdentityList_from_identity_list(il, &session->sync_state.keysync.identities);
        free_identity_list(il);
        if (!r)
            return PEP_OUT_OF_MEMORY;
    ||
}

action disable;

