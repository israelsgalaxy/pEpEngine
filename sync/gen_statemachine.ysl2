// generate state machine code

// Copyleft (c) 2016, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {
    include ./functions.ysl2

    template "/protocol" {
        document "../src/Makefile.protocols", "text"
            apply "fsm", 0, mode="make";
        apply "fsm", 0, mode=gen;
    }

    template "fsm", mode=make
    ||
    «@filename»_fsm.c: ../sync/devicegroup.fsm
    \tmake -C ../«@filename»
    ||

    template "fsm", mode=gen {
        document "../src/{@filename}_fsm.h", "text" {
        ||
        #pragma once

        // state machine for «@name»

        #include "pEpEngine.h"
        #include "message.h"
        #include "../asn.1/«../@name»-Protocol.h"
        
        #ifdef __cplusplus
        extern "C" {
        #endif

        // types

        typedef pEp_identity * Identity;
        typedef stringlist_t * Stringlist;
        typedef union _param { Identity partner; stringlist_t *keylist; } param_t;

        // error values

        typedef enum _fsm_error {
            invalid_state = -2,
            invalid_event = -3
        } fsm_error;

        // conditions

        `` for "func:distinctName(condition)" | bool «@name»(PEP_SESSION session`apply "parm", 0`);

        // states

        typedef enum _«@name»_state {
            «@name»_state_NONE = 0,
        `` for "func:distinctName(state)" |> «@name»`if "position()!=last()" > , `
        } «@name»_state;

        // events

        typedef enum _«@name»_event {
            «@name»_event_NONE = 0,
        ||
        for "func:distinctName(state/event[not(not(/protocol/fsm/tag/@name=@name))])" {
            const "name", "@name";
            |> «$name» = «/protocol/fsm/tag[@name=$name]/@id»,
        }
        for "func:distinctName(state/event[not(/protocol/fsm/tag/@name=@name)])"
            |> «@name»`if "position()!=last()" > , `
        ||
        } «@name»_event;

        // actions

        `` const "name", "@name"
        `` for "func:distinctName(//action)" | PEP_STATUS «@name»(PEP_SESSION session, «$name»_state state, Identity partner, void *extra);

        // message receiver
        
        PEP_STATUS receive_«@name»_msg(PEP_SESSION session, message *msg);

        // state machine

        «@name»_state fsm_«@name»(
                PEP_SESSION session,
                «@name»_state state,
                «@name»_event event,
                Identity partner,
                void *extra
            );

        // driver

        DYNAMIC_API PEP_STATUS fsm_«@name»_inject(
                PEP_SESSION session,
                «@name»_event event,
                Identity partner,
                void *extra
            );

        #ifdef __cplusplus
        }
        #endif

        ||
        }
        document "../src/{@filename}_driver.c", "text"
        ||
        // Driver for «@name» state machine

        #include <assert.h>
        #include "pEp_internal.h"


        DYNAMIC_API PEP_STATUS fsm_«@name»_inject(
                PEP_SESSION session,
                «@name»_event event,
                Identity partner,
                void *extra
            )
        {
            assert(session);
            if (!session)
                return PEP_ILLEGAL_VALUE;

            session->«@filename»_state = fsm_«@name»(session, session->«@filename»_state,
                    event, partner, extra);

            return PEP_STATUS_OK;
        }

        ||
        document "../src/{@filename}_fsm.c", "text"
        ||
        #include "«@filename»_fsm.h"

        // state machine for «@name»

        «@name»_state fsm_«@name»(
                PEP_SESSION session,
                «@name»_state state,
                «@name»_event event,
                Identity partner,
                void *extra
            )
        {
            switch (state) {
            `` apply "state", 2
                default:
                    return («@name»_state) invalid_state;
            }

            return state;
        }

        ||
    }

    template "state"
    ||
    case «@name»:
        switch (event) {
        `` apply "event", 2
            default:
                return («../@name»_state) invalid_event;
        }
        break;

    ||

    template "event"
    ||
    case «@name»:
    `` apply "action|transition|condition";
    `` if "name(*[position()=last()]) != 'transition'" |> break;
    ||

    template "action" {
        indent(0);
        > «@name»(session, state, 
        choose {
            when "parm" > «name(parm/*)»
            otherwise > NULL
        }
        > , NULL);\n
    }

    template "condition" {
        | if («@name»(session`apply "parm", 0`)) {
        apply "action|transition|condition";
        | }
    }

    template "parm" choose {
        when "count(*) = 1"
            > , «name(*)»
        otherwise
            > , «name(*[1])» «name(*[2])»
    }

    template "transition" | return «@target»;
}

