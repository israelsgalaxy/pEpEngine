// generate state machine code

// Copyleft (c) 2016, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {

    key "ActionByNames", "/protocol/fsm/state/event//action", "@name";
    variable "UniqueActions", "/protocol/fsm/state/event//action[generate-id()=generate-id(key('ActionByNames',@name)[1])]";

    template "/protocol/fsm"
    ||
    // state machine for «@name»

    #include "pEpEngine.h"

    typedef union _param { const pEp_identity *partner; const stringlist_t *keylist; } param_t;

    // error values

    typedef enum _fsm_error {
        invalid_state = -1,
        invalid_event = -2
    } fsm_error;

    // states

    typedef enum _«@name»_state {
    `` for "set:distinct(state/@name)" |> «.»`if "position()!=last()" > , `
    } «@name»_state;

    // events

    typedef enum _«@name»_event {
    `` for "set:distinct(state/event/@name)" |> «.»`if "position()!=last()" > , `
    } «@name»_event;

    // actions

    `` for "set:distinct(state/event//action/@name)" | void «.»(const pEp_identity *partner);

    // decoders

    `` apply "$UniqueActions[starts-with(@name,'send')]",0 mode="proto" with "pfx", "'decode'"

    // encoders 

    `` apply "$UniqueActions[starts-with(@name,'send')]",0 mode="proto" with "pfx", "'encode'"

    // state machine

    «@name»_state fsm_«@name»(
            «@name»_state state,
            «@name»_event event,
            const pEp_identity *partner
        )
    {
        switch (state) {
            `` apply "state"
            default:
                return invalid_state;
        }

        return state;
    }

    ||

    template "state"
    ||
    case «@name»:
        switch (event) {
        `` apply "event", 2
        default:
            return invalid_event;
        }
        break;

    ||

    template "event"
    ||
    case «@name»:
    `` apply "action|transition";
    `` if "name(*[position()=last()]) != 'transition'" |> break;
    ||

    template "action" {
        indent(0);
        > «@name»(
        choose {
            when "parm" > «name(parm/*)»
            otherwise > NULL
        }
        > );\n
    }

    def "xsl:typeOfActionParam" {
        param "n", "name(.)";
        result "name(ancestor::event/child::parm[child::*[position()=2 and name(.)=$n]]/child::*[position()=1])";
    }

    template "action", mode="proto" {
        param "pfx";
        > void «$pfx»«substring-after(@name, 'send')»(
        if "count(parm/*) = 0"
            > void
        for "set:distinct(parm/*)" {
            > «xsl:typeOfActionParam()» «name(.)»
            if "position() != last()" > ,
        }
        | );
    }

    template "transition" | return «@target»;
}

