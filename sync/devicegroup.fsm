// DeviceGroup protocol for p≡p

// Copyleft (c) 2016, p≡p foundation

// Written by Volker Birk

include ./fsm.yml2

protocol DeviceGroup {
    // all messages have a timestamp, time out and are removed after timeout

    broadcast sendBeacon;
    unencrypted sendBeacon;

    fsm DeviceState filename=sync {
        condition storedGroupKeys();
        condition keyElectionWon(Identity partner);

        state InitState {
            on Init {
                if storedGroupKeys()
                    go Grouped;
                go Sole;
            }
        }

        state Sole {
            on KeyGen // injected by generate_keypair()
                do sendBeacon;
            on CannotDecrypt
                do sendBeacon;  // cry, baby
            on Beacon(Identity partner) // this event will not happen for already
                                        // rejected partners
                do sendHandshakeRequest(partner);
            on HandshakeRequest(Identity partner) {
                do sendHandshakeRequest(partner);
                go HandshakingSole(partner);
            }
        }

        state HandshakingSole(Identity partner) {
            on Init
                do showHandshake(partner);
            on HandshakeRejected(Identity partner) {
                do rejectHandshake(partner);             // stores rejection of partner
                go Sole;
            }
            on HandshakeAccepted(Identity partner) {
                do acceptHandshake(partner); 
                if keyElectionWon(partner) {    // an already existing group
                                                // always wins
                    do sendGroupKeys(partner);
                    go Grouped;
                }
                go WaitForGroupKeysSole(Identity partner);
            }
        }
    
        state WaitForGroupKeysSole(Identity partner) {
            on GroupKeys(Identity partner, Stringlist keys) {
                do storeGroupKeys(partner, keys);
                // TODO : add a callback to signal finished waiting for group keys
                go Grouped;
            }
            on Cancel go Sole;
            on Reject(Identity partner) {
                do rejectHandshake(partner);
                go Sole;
            }
        }

        state Grouped {
            on KeyGen
                do sendGroupKeys; // always send all keys
            on Beacon(Identity partner)
                do sendHandshakeRequest(partner);
            on HandshakeRequest(Identity partner) {
                do sendHandshakeRequest(partner);
                go HandshakingGrouped(partner);
            }
        }

        state HandshakingGrouped(Identity partner) {
            on Init
                do showHandshake(partner);
            on HandshakeRejected(Identity partner) {
                do rejectHandshake(partner);             // stores rejection of partner
                go Grouped;
            }
            on HandshakeAccepted(Identity partner) {
                do acceptHandshake(partner); 

                // an already existing group always wins
                do sendGroupKeys(partner);
                go Grouped;
            }
        }
    

        tag Init 1;
        tag Beacon 2;
        tag HandshakeRequest 3;
        tag GroupKeys 4;
    }
}

