// This file is under GNU General Public License 3.0
// see LICENSE.txt

// generate conditions and actions

// Copyleft (c) 2018, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {
    include standardlib.ysl2

    template "/protocol" {
        document "generated/{yml:lcase(@name)}_codec.h", "text"
        ||
        // This file is under GNU General Public License 3.0
        // see LICENSE.txt

        #pragma once


        #include "pEpEngine.h"


        #ifdef __cplusplus
        extern "C" {
        #endif


        struct «@name»;

        // decode_«@name»_message() - decode PER encoded «@name» message
        //
        //  parameters:
        //      data (in)               PER encoded data
        //      size (in)               size of PER encoded data
        //      msg (out)               «@name» message
        //
        //  caveat:
        //      msg goes into the ownership of the caller

        DYNAMIC_API PEP_STATUS decode_«@name»_message(
                const char *data,
                size_t size,
                struct «@name» **msg
            );


        // encode_«@name»_message() - encode «@name» message into PER encoded data
        //
        //  parameters:
        //      msg (in)                «@name» message
        //      data (out)              PER encoded data
        //      size (out)              size of PER encoded data
        //
        //  caveat:
        //      data goes to the ownership of the caller

        DYNAMIC_API PEP_STATUS encode_«@name»_message(
                struct «@name» *msg,
                char **data,
                size_t *size
            );


        // PER_to_XER_«@name»_msg() - decode «@name» message from PER into XER
        //
        //  parameters:
        //      data (in)               PER encoded data
        //      size (in)               size of PER encoded data
        //      text (out)              XER text of the same «@name» message

        DYNAMIC_API PEP_STATUS PER_to_XER_«@name»_msg(
                const char *data,
                size_t size,
                char **text
            );


        // XER_to_PER_«@name»_msg() - encode «@name» message from XER into PER
        //
        //  parameters:
        //      text (in)               string with XER text of the «@name» message
        //      data (out)              PER encoded data
        //      size (out)              size of PER encoded data

        DYNAMIC_API PEP_STATUS XER_to_PER_«@name»_msg(
                const char *text,
                char **data,
                size_t *size
            );


        #ifdef __cplusplus
        }
        #endif

        ||
        document "generated/{yml:lcase(@name)}_codec.c", "text"
        ||
        // This file is under GNU General Public License 3.0
        // see LICENSE.txt

        #include "«yml:lcase(@name)»_codec.h"
        #include "../asn.1/«@name».h"
        #include "pEp_internal.h"
        #include "growing_buf.h"

        DYNAMIC_API PEP_STATUS decode_«@name»_message(
                const char *data,
                size_t size,
                «@name»_t **msg
            )
        {
            assert(data && msg);
            if (!(data && msg))
                return PEP_ILLEGAL_VALUE;

            *msg = NULL;
            «@name»_t *_msg = NULL;
            uper_decode_complete(NULL, &asn_DEF_«@name», (void **) &_msg, data, size);
            if (!_msg)
                return PEP_«yml:ucase(@name)»_ILLEGAL_MESSAGE;

            *msg = _msg;
            return PEP_STATUS_OK;
        }

        DYNAMIC_API PEP_STATUS encode_«@name»_message(
                «@name»_t *msg,
                char **data,
                size_t *size
            )
        {
            assert(data && msg);
            if (!(data && msg))
                return PEP_ILLEGAL_VALUE;

            *data = NULL;
            *size = 0;

            char *_data = NULL;
            ssize_t _size = uper_encode_to_new_buffer(&asn_DEF_«@name», NULL, msg,
                    (void **) &_data);
            if (_size == -1)
                return PEP_CANNOT_ENCODE;

            *data = _data;
            *size = (size_t) _size;

            return PEP_STATUS_OK;
        }

        DYNAMIC_API PEP_STATUS PER_to_XER_«@name»_msg(
                const char *data,
                size_t size,
                char **text
            )
        {
            PEP_STATUS status = PEP_STATUS_OK;
            growing_buf_t *dst = NULL;

            assert(data && text);
            if (!(data && text))
                return PEP_ILLEGAL_VALUE;

            *text = NULL;

            «@name»_t *msg = NULL;
            status = decode_«@name»_message(data, size, &msg);
            if (status)
                goto the_end;

            dst = new_growing_buf();
            if (!dst) {
                status = PEP_OUT_OF_MEMORY;
                goto the_end;
            }

            asn_enc_rval_t er = xer_encode(&asn_DEF_«@name», msg, XER_F_BASIC,
                    (asn_app_consume_bytes_f *) growing_buf_consume, (void *) dst);
            if (er.encoded == -1) {
                status = PEP_CANNOT_ENCODE;
                goto the_end;
            }

            *text = dst->data;
            dst->data = NULL;

        the_end:
            free_growing_buf(dst);
            ASN_STRUCT_FREE(asn_DEF_«@name», msg);
            return status;
        }

        DYNAMIC_API PEP_STATUS XER_to_PER_«@name»_msg(
                const char *text,
                char **data,
                size_t *size
            )
        {
            PEP_STATUS status = PEP_STATUS_OK;

            assert(text && data && size);
            if (!(text && data && size))
                return PEP_ILLEGAL_VALUE;

            *data = NULL;
            *size = 0;

            «@name»_t *msg = NULL;
            asn_dec_rval_t dr = xer_decode(NULL, &asn_DEF_«@name», (void **) &msg,
                    (const void *) text, strlen(text));
            if (dr.code != RC_OK) {
                status = PEP_«yml:ucase(@name)»_ILLEGAL_MESSAGE;
                goto the_end;
            }

            char *_data = NULL;
            size_t _size = 0;
            status = encode_«@name»_message(msg, &_data, &_size);
            if (status)
                goto the_end;

            *data = _data;
            *size = (size_t) _size;

        the_end:
            ASN_STRUCT_FREE(asn_DEF_«@name», msg);
            return status;
        }

        ||
    }
}

