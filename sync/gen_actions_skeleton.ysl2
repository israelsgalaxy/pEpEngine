// generate actions skeleton

// Copyleft (c) 2016, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {
    include ./functions.ysl2

    template "/protocol" {
        apply "fsm", mode=send, 0;
        apply "fsm", mode=other, 0;
    }

    template "fsm", mode=send document "../src/{@filename}_send_actions.c", "text" {
        const "name", "@name";
        const "filename", "@filename";
        ||
        // Send Actions for «@name» state machine

        #include <assert.h>
        #include "pEp_internal.h"
        #include "keymanagement.h"
        #include "message.h"
        #include "«@filename»_fsm.h"
        #include "baseprotocol.h"
        #include "map_asn1.h"
        #include "../asn.1/DeviceGroup-Protocol.h"
        ||
        for "func:distinctName(//action)"
            if "substring(@name, 1, 4) = 'send'"
                | #include "../asn.1/«substring(@name, 5, 255)».h"
        |
        for "func:distinctName(//action)"
            if "substring(@name, 1, 4) = 'send'"
                call "send_action"
                    with "action", ".",
                    with "fsm", "$name",
                    with "filename", "$filename";
    }

    template "fsm", mode=other document "../src/{@filename}_actions.c.skeleton", "text" {
        const "name", "@name";
        const "filename", "@filename";
        ||
        // Actions for «@name» state machine

        #include <assert.h>
        #include "pEp_internal.h"
        #include "keymanagement.h"
        #include "message.h"
        #include "«@filename»_fsm.h"
        #include "../asn.1/DeviceGroup-Protocol.h"

        ||
        for "func:distinctName(//action)"
            if "substring(@name, 1, 4) != 'send'"
                call "other_action"
                    with "action", ".",
                    with "fsm", "$name",
                    with "filename", "$filename";
    }

    function "paramcheck" {
        param "partner";
        |> assert(session);
        choose {
            when "$partner"
            ||
                assert(partner);
                if (!(session && partner))
                    return PEP_ILLEGAL_VALUE;
            ||
            otherwise
            ||
                assert(!partner);
                if (!(session && !partner))
                    return PEP_ILLEGAL_VALUE;
            ||
        }
    }

    function "other_action" {
        param "action";
        param "fsm";
        param "filename", "'###'";

        ||

        // «$action/@name»() - 
        //
        //  params:
        //      session (in)        session handle
        //      state (in)          state the state machine is in
        `` if "parm"        | //      partner (in)        partner to communicate with
        `` if "not(parm)"   | //      partner (in)        (must be NULL)
        //
        //  returns:
        //      PEP_STATUS_OK or any other value on error

        PEP_STATUS «$action/@name»(
                PEP_SESSION session,
                «$fsm»_state state,
                Identity partner,
                void *extra
            )
        {
            PEP_STATUS status = PEP_STATUS_OK;

            `` call "paramcheck" with "partner", "parm/partner";

            // working code

            free_identity(partner);
            // free extra
            return status;

        enomem:
            status = PEP_OUT_OF_MEMORY;
        error:
            free_identity(partner);
            // free extra
            return status;
        }

        ||
    }

    function "send_action" {
        param "action";
        param "fsm";
        param "filename", "'###'";
        const "name", "substring($action/@name, 5, 255)";

        ||

        // «$action/@name»() - send «$name» message
        //
        //  params:
        //      session (in)        session handle
        //      state (in)          state the state machine is in
        `` if "parm"        | //      partner (in)        partner to communicate with
        `` if "not(parm)"   | //      partner (in)        (must be NULL)
        //
        //  returns:
        //      PEP_STATUS_OK or any other value on error

        PEP_STATUS «$action/@name»(
                PEP_SESSION session,
                «$fsm»_state state,
                Identity partner,
                void *extra
            )
        {
            PEP_STATUS status = PEP_STATUS_OK;
            «$name»_t *msg = NULL;
            char *payload = NULL;
            message *_message = NULL;
            pEp_identity *me = NULL;
            `` if "$name='GroupKeys'" |> identity_list *kl = NULL;

            `` call "paramcheck" with "partner", "parm/partner";

            assert(session->messageToSend);
            if (!session->messageToSend) {
                status = PEP_SEND_FUNCTION_NOT_REGISTERED;
                goto error;
            }

            msg = («$name»_t *) calloc(1, sizeof(«$name»_t));
            assert(msg);
            if (!msg)
                goto enomem;

            int32_t seq;
            status = sequence_value(session, "DeviceGroup", &seq);
            if (status != PEP_STATUS_OK)
                goto error;
            msg->header.sequence = (long) seq;

            bool devicegroup = storedGroupKeys(session);
            if (devicegroup) { // default is FALSE
                BOOLEAN_t *dg = malloc(sizeof(BOOLEAN_t));
                assert(dg);
                if (!dg)
                    goto enomem;

                *dg = 1;
                msg->header.devicegroup = dg;
            }

            msg->header.state = (long) state;

            me = new_identity(NULL, NULL, NULL, NULL);
            if (!me)
                goto enomem;
            status = myself(session, me);
            if (status != PEP_STATUS_OK)
                goto error;
            if (Identity_from_Struct(me, &msg->header.me) == NULL)
                goto enomem;
        ||
        if "$name='GroupKeys'" {
            |
            |> status = own_identities_retrieve(session, &kl);
            |> if (status != PEP_STATUS_OK)
            |>> goto error;
            |> if (IdentityList_from_identity_list(kl, &msg->ownIdentities) == NULL)
            |>> goto enomem;
        }
        ||

            if (asn_check_constraints(&asn_DEF_«$name», msg, NULL, NULL)) {
                status = PEP_CONTRAINTS_VIOLATED;
                goto error;
            }

            ssize_t size = uper_encode_to_new_buffer(&asn_DEF_«$name»,
                    NULL, msg, (void **) &payload);
            if (size == -1) {
                status = PEP_CANNOT_ENCODE;
                goto error;
            }

            status = prepare_message(me, partner, payload, size, &_message);
            if (status != PEP_STATUS_OK)
                goto error;
            payload = NULL;

            free_identity(me);
            me = NULL;

            status = session->messageToSend(session->«$filename»_obj, _message);

            free_message(_message);
            ASN_STRUCT_FREE(asn_DEF_«$name», msg);
            free_identity(partner);
            `` if "$name='GroupKeys'" |> free_identity_list(kl);
            return status;

        enomem:
            status = PEP_OUT_OF_MEMORY;
        error:
            ASN_STRUCT_FREE(asn_DEF_«$name», msg);
            free(payload);
            free_message(_message);
            free_identity(me);
            free_identity(partner);
            `` if "$name='GroupKeys'" |> free_identity_list(kl);
            return status;
        }

        ||
    }
}

