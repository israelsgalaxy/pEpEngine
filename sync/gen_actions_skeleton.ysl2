// generate actions skeleton

// Copyleft (c) 2016, p≡p foundation

// Written by Volker Birk

include yslt.yml2

tstylesheet {
    include ./functions.ysl2

    template "/protocol/fsm" document "../src/{@filename}_actions.c.skeleton", "text" {
        const "name", "@name";
        const "filename", "@filename";
    ||
    // Actions for «@name» state machine

    #include <assert.h>
    #include "pEp_internal.h"
    #include "keymanagement.h"
    #include "message.h"
    #include "«@filename»_fsm.h"
    #include "baseprotocol.h"
    #include "map_asn1.h"
    `` for "func:distinctName(//action)" if "substring(@name, 1, 4) = 'send'" | #include "../asn.1/«substring(@name, 5, 255)».h"

    `` for "func:distinctName(//action)" call "action" with "action", ".", with "fsm", "$name", with "filename", "$filename";

    ||
    }

    function "action" {
        param "action";
        param "fsm";
        param "filename", "'###'";
        choose {
            when "substring($action/@name, 1, 4) = 'send'"
                call "send_action" with "action", "$action",
                     with "fsm", "$fsm", with "filename", "$filename";
            otherwise
                call "other_action" with "action", "$action",
                     with "fsm", "$fsm", with "filename", "$filename";
        }
    }

    function "paramcheck" {
        param "partner";
        |> assert(session);
        choose {
            when "$partner"
            ||
                assert(partner);
                if (!(session && partner))
                    return PEP_ILLEGAL_VALUE;
            ||
            otherwise
            ||
                assert(!partner);
                if (!(session && !partner))
                    return PEP_ILLEGAL_VALUE;
            ||
        }
    }

    function "other_action" {
        param "action";
        param "fsm";
        param "filename", "'###'";

        ||

        // «$action/@name»() - 
        //
        //  params:
        //      session (in)        session handle
        //      state (in)          state the state machine is in
        `` if "parm"        | //      partner (in)        partner to communicate with
        `` if "not(parm)"   | //      partner (in)        (must be NULL)
        //
        //  returns:
        //      PEP_STATUS_OK or any other value on error

        PEP_STATUS «$action/@name»(
                PEP_SESSION session,
                «$fsm»_state state,
                const Identity partner
            )
        {
            PEP_STATUS status = PEP_STATUS_OK;

            `` call "paramcheck" with "partner", "parm/partner";

            // working code


            return status;

        enomem:
            status = PEP_OUT_OF_MEMORY;
        error:
            // free...
            return status;
        }

        ||
    }

    function "send_action" {
        param "action";
        param "fsm";
        param "filename", "'###'";
        const "name", "substring($action/@name, 5, 255)";

        ||

        // «$action/@name»() - send «$name» message
        //
        //  params:
        //      session (in)        session handle
        //      state (in)          state the state machine is in
        `` if "parm"        | //      partner (in)        partner to communicate with
        `` if "not(parm)"   | //      partner (in)        (must be NULL)
        //
        //  returns:
        //      PEP_STATUS_OK or any other value on error

        PEP_STATUS «$action/@name»(
                PEP_SESSION session,
                «$fsm»_state state,
                const Identity partner
            )
        {
            PEP_STATUS status = PEP_STATUS_OK;
            «$name»_t *msg = NULL;
            char *payload = NULL;
            message *_message = NULL;
            pEp_identity *me = NULL;

            `` call "paramcheck" with "partner", "parm/partner";

            assert(session->messageToSend);
            if (!session->messageToSend)
                return PEP_SEND_FUNCTION_NOT_REGISTERED;

            msg = («$name»_t *) calloc(1, sizeof(«$name»_t));
            assert(msg);
            if (!msg)
                goto enomem;

            int32_t seq;
            status = sequence_value(session, "DeviceGroup", &seq);
            if (status != PEP_STATUS_OK)
                goto error;
            msg->header.sequence = (long) seq;

            msg->state = (long) state;

            me = new_identity(NULL, NULL, NULL, NULL);
            if (!me)
                goto enomem;
            status = myself(session, me);
            if (status != PEP_STATUS_OK)
                goto error;
            if (Identity_from_Struct(me, &msg->me) == NULL)
                goto enomem;
         `` if "parm or $name='OwnKeys'" |
         `` if "parm/partner"   |> if (Identity_from_Struct(partner, &msg->partner) == NULL)
         `` if "parm/partner"   |>> goto enomem;
         `` if "$name='OwnKeys'"|> stringlist_t *sl;
         `` if "$name='OwnKeys'"|> status = own_key_retrieve(session, &sl);
         `` if "$name='OwnKeys'"|> if (status != PEP_STATUS_OK)
         `` if "$name='OwnKeys'"|>> goto error;
         `` if "$name='OwnKeys'"|> if (KeyList_from_stringlist(sl, &msg->keylist) == NULL)
         `` if "$name='OwnKeys'"|>> goto enomem;

            if (asn_check_constraints(&asn_DEF_«$name», msg, NULL, NULL)) {
                status = PEP_CONTRAINTS_VIOLATED;
                goto error;
            }

            ssize_t size = uper_encode_to_new_buffer(&asn_DEF_«$name»,
                    NULL, msg, (void **) &payload);
            if (size == -1) {
                status = PEP_CANNOT_ENCODE;
                goto error;
            }

            status = prepare_message(me, partner, payload, size, &_message);
            if (status != PEP_STATUS_OK)
                goto error;
            payload = NULL;

            free_identity(me);
            me = NULL;

            status = session->messageToSend(session->«$filename»_obj, _message);

            free_message(_message);
            ASN_STRUCT_FREE(asn_DEF_«$name», msg);

            return status;

        enomem:
            status = PEP_OUT_OF_MEMORY;
        error:
            ASN_STRUCT_FREE(asn_DEF_«$name», msg);
            free(payload);
            free_message(_message);
            free_identity(me);
            return status;
        }

        ||
    }
}

