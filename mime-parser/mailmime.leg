# TODO, DON'T FORGET - CHECK OWNERSHIP ON ALL ENGINE DS FUNCTIONS AND OMIT STRDUPS WHEN POSSIBLE
# CLEAN UP MEMORY ON FAILURE
# ERROR HANDLING AND RECOVERY
# ALL THE THINGS
#
%{
#define YYSTYPE void*
#include "../src/stringpair.h"
#include "../src/message.h"
%}

Mail                    =      ( Header )+ CRLF ( Body )? EOF

Header                  =     ( MIMEHeader  | 
                                MessageHeader  | 
                                GenericHeader )

#FIXME: Do we need to strip the last CRLF from the headertext?
GenericHeader           =      HeaderKey COLON_PLUS_WS <HeaderText> 
                                    {
                                        stringpair_list_add(yy->parsed_msg->opt_fields, new_stringpair(yy->tmp_key, yytext));
                                        free(yy->tmp_key);
                                        yy->tmp_key = NULL;
                                    }
                                   ~{/* FAIL */
                                        if (yy->tmp_key)
                                            free(yy->tmp_key);
                                        yy->tmp_key = NULL;
                                    }

HeaderKey               =      < ( Alpha | Digit | OrdinarySymbol )+ >
                                    {
                                        yy->tmp_key = strdup(yytext);
                                    }                        

HeaderText              =      HeaderLine ( HeaderCont )* 
HeaderCont              =      Whitespace HeaderLine
HeaderPhrase            =      EncodedWord | Word
HeaderLine              =      (HeaderPhrase | Whitespace)* CRLF

#MIME Header Blocks

# Mime-related headers
MIMEHeader              =      MIMEVersionHeader |
                               MIMEContentIDHeader |
                               MIMEContentTypeHeader |
                               MIMETransfEncodeHeader |
                               MIMEContentDescHeader |
                               MIMEExtensionHeader


# TODO NEXT: Translate headers so we get the parts etc into the right places.
MIMEExtensionHeader     =      MIMEContentDispoHeader | MIMEGenericExtHeader
MIMEVersionHeader       =      MIMEVersionKey COLON_PLUS_WS < VersionString >
                                    {
                                        stringpair_list_add(yy->parsed_msg->opt_fields, new_stringpair("MIME-Version", yytext));
                                    }
MIMEContentTypeHeader   =      MIMEContentTypeKey COLON_PLUS_WS ContentTypeString
MIMEContentIDHeader     =      MIMEContentIDKey COLON_PLUS_WS ContentIDString
MIMETransfEncodeHeader  =      MIMETransfEncodeKey COLON_PLUS_WS TransfEncodeString
MIMEContentDescHeader   =      MIMEContentDescKey COLON_PLUS_WS ContentDescString

MIMEContentDispoHeader  =      MIMEContentDispoKey COLON_PLUS_WS ContentDispoString
MIMEGenericExtHeader    =      MIMEExtensionKey COLON_PLUS_WS ExtensionString

MIMEContentRelevField   =      MIMEContentTypeHeader 
                                | MIMEContentIDHeader 
                                | MIMETransfEncodeHeader 
                                | MIMEContentDescHeader 
                                | MIMEContentDispoHeader 
                                | MIMEGenericExtHeader 

MIMEVersionKey          =      'MIME-Version'
MIMEContentTypeKey      =      'Content-Type'
MIMEContentDispoKey     =      'Content-Disposition'
MIMETransfEncodeKey     =      'Content-Transfer-Encoding'
MIMEContentIDKey        =      'Content-ID'
MIMEContentDescKey      =      'Content-Description'
MIMEExtensionKey        =      'Content-'HeaderKey

#VersionString           =     Text* Digit Text* "." Text* Digit Text* 
VersionString           =      HeaderText
ContentTypeString       =      ContentType "|" ContentSubtype (";" Parameter)*
ContentDispoString      =      ContentDisposition
TransfEncodeString      =      "7bit" | "8bit" | "binary" |
                                "quoted-printable" | "base64" |
                                XToken | IETFToken
ContentIDString         =      MsgID
ContentDescString       =      HeaderText
ExtensionString         =      HeaderText

# RFC2045 Section 5 - we should extend these to ones we care about
ContentType             =      DiscreteContentType | CompositeContentType
DiscreteContentType     =      "text" | "image" | "audio" | 
                                "video" | "application" | 
                                ExtensionToken
CompositeContentType    =      "message" | "multipart" | 
                                ExtensionToken
ExtensionToken          =      XToken | IETFToken
XToken                  =      "X-" Token
IETFToken               =      Token
ContentSubtype          =      "mixed" | "digest" | "rfc822" | "alternative" | "related" |
                                "signed" | "encrypted" | "pgp-encrypted" | "pgp-keys" | "pgp-signature" 
                                | ExtensionToken | IANAToken
IANAToken               =      Token

Parameter               =      RegularParameter | ExtendedParameter
RegularParameter        =      RegularParameterName "=" Value
RegularParameterName    =      Attribute Section?
Value                   =      Token | QuotedString
Token                   =      (![TSpecials ASCII_CTL Space] ASCII_CHAR)?
Attribute               =      AttributeChar+
AttributeChar           =      (![NonAttributeChar] ASCII_Printable)
NonAttributeChar        =      Space | "*" | "'" | "%" | TSpecials
Section                 =      InitialSection | OtherSections
InitialSection          =      "*0"
OtherSections           =      "*" ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") Digit*
ExtendedParameter       =      (ExtendedInitialName "=" ExtendedInitialValue) |
                                (ExtendedOtherNames "="ExtendedOtherValues)
ExtendedInitialName     =      Attribute InitialSection? "*"
ExtendedOtherNames      =      Attribute OtherSections "*"
ExtendedInitialValue    =      [Charset] "'" [Language] "'" ExtendedOtherValues
ExtendedOtherValues     =      (ExtOctet | AttributeChar)*
ExtOctet                =      "%" HexDigit HexDigit


ContentDisposition      =      DispositionType *( ";" DispositionParm )
DispositionType         =      "inline" | "attachment" | DispExtType
DispExtType             =      Token
DispositionParm         =      FilenameParm | DispositionExtParm
FilenameParm            =      "filename" "=" Value | "filename*" "=" ExtValue
DispositionExtParm      =      Token "=" Value | ExtToken "=" ExtValue
ExtToken                =      Token "*"
ExtValue                =      Value

# Message-related headers (per RFC2822)
MessageHeader           =     (( MessageIDHeader |
                                MessageToHeader |
                                MessageFromHeader |
                                MessageCCHeader |
                                MessageBCCHeader |
                                MessageReplyToHeader |
                                MessageInReplyToHeader |
                                MessageRefsHeader ) CRLF) 
                                | MessageSubjHeader
                                
MessageIDHeader         =      MessageIDKey COLON_PLUS_WS IDString
MessageToHeader         =      MessageToKey COLON_PLUS_WS ToString  
MessageFromHeader       =      MessageFromKey COLON_PLUS_WS FromString
MessageCCHeader         =      MessageCCKey COLON_PLUS_WS CCString
MessageBCCHeader        =      MessageBCCKey COLON_PLUS_WS BCCString
MessageSubjHeader       =      MessageSubjKey COLON_PLUS_WS SubjString
MessageReplyToHeader    =      MessageReplyToKey COLON_PLUS_WS ReplyToString
MessageInReplyToHeader  =      MessageInReplyToKey COLON_PLUS_WS InReplyToString
MessageRefsHeader       =      MessageRefsKey COLON_PLUS_WS RefsString
MessageIDKey            =      'Message-ID'
MessageToKey            =      'To'
MessageFromKey          =      'From'
MessageCCKey            =      'Cc'
MessageBCCKey           =      'Bcc'
MessageSubjKey          =      'Subject'
MessageReplyToKey       =      'Reply-To'
MessageInReplyToKey     =      'In-Reply-To'
MessageRefsKey          =      'References'  
IDString                =       MsgID 
                                    {
                                        yy->parsed_msg->id = strdup(yy->curr_msg_id_list->value);
                                        free(yy->curr_msg_id_list);
                                    }
ToString                =      AddressList 
                                    {
                                        yy->parsed_msg->to = yy->curr_address_list;
                                        yy->curr_address_list = NULL;
                                    } 
                                   ~{/* FAIL */
                                        if (yy->curr_address_list)
                                            free_identity_list(yy->curr_address_list);
                                        yy->curr_address_list = NULL;
                                    }
                                                
FromString              =      MailboxList 
                                    {
                                        yy->parsed_msg->from = identity_dup(yy->curr_address_list->ident); 
                                        free_identity_list(yy->curr_address_list); 
                                        yy->curr_address_list->ident = NULL; 
                                    }
                                    ~{/* FAIL */
                                        if (yy->curr_address_list)
                                            free_identity_list(yy->curr_address_list);
                                        yy->curr_address_list = NULL;
                                    }

CCString                =      AddressList {yy->parsed_msg->cc = yy->curr_address_list; 
                                            yy->curr_address_list = NULL;}
                                   ~{/* FAIL */
                                        if (yy->curr_address_list)
                                            free_identity_list(yy->curr_address_list);
                                        yy->curr_address_list = NULL;
                                    }
BCCString               =      AddressList 
                                    {
                                        yy->parsed_msg->bcc = yy->curr_address_list; 
                                        yy->curr_address_list = NULL;
                                    }
                                   ~{/* FAIL */
                                        if (yy->curr_address_list)
                                            free_identity_list(yy->curr_address_list);
                                        yy->curr_address_list = NULL;
                                    }

SubjString              =      < HeaderText > 
                                    {
                                        yy->parsed_msg->shortmsg = strdup(yytext);
                                    }
ReplyToString           =      AddressList 
                                    {
                                        yy->parsed_msg->reply_to = yy->curr_address_list; 
                                        yy->curr_address_list = NULL;
                                    }
                                   ~{/* FAIL */
                                        if (yy->curr_address_list)
                                            free_identity_list(yy->curr_address_list);
                                        yy->curr_address_list = NULL;
                                    } 
InReplyToString         =      MsgID+ 
                                    {
                                        yy->parsed_msg->in_reply_to = yy->curr_msg_id_list; 
                                        yy->curr_msg_id_list = NULL;
                                    }
                                    ~{/* FAIL */
                                        if (yy->curr_msg_id_list)
                                            free_identity_list(yy->curr_msg_id_list);
                                        yy->curr_msg_id_list = NULL;
                                    }

RefsString              =      MsgID+ 
                                    {
                                        yy->parsed_msg->references = yy->curr_msg_id_list; 
                                        yy->curr_msg_id_list = NULL;
                                    }
                                    ~{/* FAIL */
                                        if (yy->curr_msg_id_list)
                                            free_identity_list(yy->curr_msg_id_list);
                                        yy->curr_msg_id_list = NULL;
                                    }

# RFC2822 Address Specification
Address                 =      Mailbox | Group 
Mailbox                 =      (mb:NameAddr | mb:AddrSpec) 
                                    { 
                                        if (!yy->curr_address_list)
                                            yy->curr_address_list = new_identity_list(mb); 
                                        else
                                            identity_list_add(yy->curr_address_list, mb); 
                                    }
# Split rule instead of using ? is because d comes back undefined when name empty otherwise
NameAddr                =      <a:AngleAddr> 
                                    { 
                                        $$ = (void*)new_identity(a, NULL, strdup(yytext), NULL); 
                                    } 
                                | <d:DisplayName a:AngleAddr> 
                                    { 
                                        int a_size = strlen(a);
                                        int d_size = strlen(d);
                                        int userid_len = a_size + d_size + 4;
                                        char* userid = (char*)malloc(sizeof(char) * (userid_len + 1));
                                        strcpy(userid, d);
                                        strncat(userid, " <", userid_len - d_size);
                                        strncat(userid, a, userid_len - (d_size + 2));
                                        strncat(userid, ">", 1);
                                        userid[userid_len] = '\0';
                                        $$ = (void*)new_identity(a, NULL, userid, d); 
                                    }
AngleAddr               =      CFWS? "<" <AddrSpec> ">" CFWS? 
                                    {
                                        $$ = strdup(yytext);
                                    } 
                                | oaa:ObsAngleAddr 
                                    {
                                        $$ = strdup(oaa);
                                    }
# FIXME: Process group
Group                   =      DisplayName ":" (MailboxList | CFWS)? ";" CFWS?
DisplayName             =      < Phrase > 
                                    {
                                        /* Unfortunately, the trailing CFWS sticks with the Phrase */
                                        size_t final_length = yyleng;
                                        char check_curr;
                                        for (check_curr = yytext[final_length - 1];
                                             (check_curr == ' ' || check_curr == '\t') && final_length >= 0;
                                             check_curr = yytext[--final_length - 1]);
                                            
                                        char* retval = (char*)malloc(sizeof(char) * (final_length + 1));
                                        strncpy(retval, yytext, final_length);
                                        retval[final_length] = '\0';

                                        $$ = retval;
                                        
                                        
                                    }
MailboxList             =      (Mailbox ("," Mailbox)*) | ObsMBoxList
AddressList             =      (Address ("," Address)*) | ObsAddrList 

AddrSpec                =      LocalPart "@" Domain
LocalPart               =      DotAtom | QuotedString | ObsLocalPart
Domain                  =      DotAtom | DomainLiteral | ObsDomain
DomainLiteral           =      CFWS? "[" (FoldingWhiteSpace? DContent)* FoldingWhiteSpace? "]" CFWS?
DContent                =      DText | QuotedPair
DText                   =      NoWSCtl |
                                [\041-\132] |
                                [\136-\176]

# Supported Obsolete Addressing
ObsAngleAddr            =      CFWS? "<" < ObsRoute? AddrSpec > ">" CFWS? {$$ = strdup(yytext);}
ObsRoute                =      CFWS? ObsDomainList ":" CFWS?
ObsDomainList           =      "@" Domain ((CFWS | "," )* CFWS? "@" Domain)*
ObsLocalPart            =      RFCWord ("." RFCWord)*
ObsDomain               =      Atom ("." Atom)*
ObsMBoxList             =      (Mailbox? CFWS? "," CFWS?)+ Mailbox?
ObsAddrList             =      (Address? CFWS? "," CFWS?)+ Address?
                      
                      
# RFC2822 Message ID
MsgID                   =       CFWS? "<" < IDLeft "@" IDRight > ">" CFWS? 
                                    { 
                                        if (!yy->curr_msg_id_list)
                                                yy->curr_msg_id_list = new_stringlist(strdup(yytext)); 
                                        else
                                                identity_list_add(yy->curr_msg_id_list, (strdup(yytext))); 
                                    }
IDLeft                  =       DotAtomText | NoFoldQuote | ObsIDLeft
IDRight                 =       DotAtomText | NoFoldLiteral | ObsIDRight
NoFoldQuote             =       "\"" *(QText | QuotedPair) "\""
NoFoldLiteral           =       "[" *(DText | QuotedPair) "]"
ObsIDLeft               =      LocalPart
ObsIDRight              =      Domain
                      
Body                    =      MIMEBody | PlainBody
PlainBody               =      .* EOF

MIMEBody                =      

# MIMEContentTypeHeader   =      MIMEContentTypeKey COLON_PLUS_WS ContentTypeString
# MIMEContentIDHeader     =      MIMEContentIDKey COLON_PLUS_WS ContentIDString
# MIMETransfEncodeHeader  =      MIMETransfEncodeKey COLON_PLUS_WS TransfEncodeString
# MIMEContentDescHeader   =      MIMEContentDescKey COLON_PLUS_WS ContentDescString
# 
# MIMEContentDispoHeader  =      MIMEContentDispoKey COLON_PLUS_WS ContentDispoString
# MIMEGenericExtHeader    =      MIMEExtensionKey COLON_PLUS_WS ExtensionString

#RFC 2045                 MAKE MORE SENSE TO CARE ABOUT THESE DURING GENERATION. HERE,
#                         WE CHOOSE TO PROCESS WHATEVER HEADERS WE FIND AND CAN BACK OUT
#                         IF WE DON'T HAVE WHAT WE NEED?
EntityHeaders           =       (MIMEContentTypeHeader CRLF)?
                                 (MIMETransfEncodeHeader CRLF)?
                                 (MessageIDHeader CRLF)?
                                 (MIMEContentDescHeader CRLF)?
                                 (MIMEGenericExtHeader CRLF)*

MIMEMessageHeaders      =       (EntityHeaders MessageHeader MIMEVersionHeader) |
                                 (Fields MIMEVersionHeader EntityHeaders) |
                                 (MIMEVersionHeader EntityHeaders Fields) |
                                 (EntityHeaders MIMEVersionHeader Fields) |
                                 (Fields EntityHeaders MIMEVersionHeader) |
                                 (MIMEVersionHeader Fields EntityHeaders) 
 
# We ignore any headers which are NOT EntityHeaders or Content headers here 
# This... what???
MIMEPartHeaders         =       (MIMEContentRelevField | MessageHeader)* EntityHeaders (MIMEContentRelevField | MessageHeader)*

Encapsulation       =      Delimiter BodyPart CRLF
CloseDelimiter      =      Delimiter "--"
Delimiter           =      CRLF DashBoundary
BodyPart            =      MIMEHeader+ (CRLF OCTET*)?
DashBoundary        =      "--" Boundary
Boundary            =      BChars* BCharsNoSpace
BCharsNoSpace       =      BChars | Space
BChars              =      Digit | Alpha | "'" | "(" | ")" |
                            "+" | "_" | "," | "-" | "." |
                            "/" | ":" | "=" | "?"
Preamble            =      DiscardText
Epilogue            =      DiscardText
DiscardText         =      ((!CRLF)* CRLF)* (!CRLF)*

CContent            =      CText | QuotedPair | Comment
CFWS                =      (FoldingWhiteSpace? Comment)* ((FoldingWhiteSpace? Comment) | FoldingWhiteSpace)
Comment             =      "(" ([FoldingWhiteSpace]? CContent)* FoldingWhiteSpace? ")"
FoldingWhiteSpace   =      (Whitespace* CRLF)? Whitespace+ |   
                            Whitespace+ (CRLF Whitespace+)*
CText               =      NoWSCtl | 
                            Alpha | Digit | CommentSymbols
QuotedString        =      CFWS '"' (FoldingWhiteSpace? QuotedContent)* FoldingWhiteSpace? '"'
QuotedContent       =      QText | QuotedPair
QText               =      !["\"" "\\" CR]
QuotedPair          =      "\\". | "\\" Text

Text                =      ( Word | Space )+
Word                =      ( AlphaNum | Symbol )+
AlphaNum            =      Alpha | Digit
Alpha               =      [a-zA-Z]
Digit               =      [0-9]
Symbol              =      OrdinarySymbol | COLON
Whitespace          =      Space+
Space               =      [' ' '\t']

OrdinarySymbol      =      ["!" "#" "$" "%" "&" "'" "*" "+" "\-" "/" "=" "?" "^" "_" "`" "{" "|" "}" "~" "\[" "\]" "@" ";" "." "<" ">" "\"" "(" ")" "," "\\"]
CommentSymbols      =      [\041-\047] | [\52-57] | [\072-\100] | [\133] | [\135-\140] | [\173-177]

TSpecials           =      !["."] (Specials | ["/" "?" "="])
Specials            =      ["(" ")" "<" ">" "@" "," ";" ":" "\\" "\"" "." "\[" "\]"]

ASCII_CHAR          =      [\000-\127]
ASCII_Printable     =      [\041-\176]
ASCII_CTL           =      [\000-\031] | [\127]
LWS                 =      CRLF? Space+



OCTET               =      '\\' (([0-1] [0-9] [0-9]) | ("2" (([0-4] [0-9]) | ("5" [0-5])))) 
COLON               =      ':'
NEWLINE             =      '\n'
CR                  =      '\r'
CRLF                =      CR CR? NEWLINE 
EOF                 =      !.
NoWSCtl             =      [\001-\010] | [\013-\014] | [\016-\037] | [\177]


HexDigit                =      (Digit | "A" | "B" | "C" | "D" | "E" | "F")

EncodedWord             =      "=?" Charset ("*" Language)? "?" EncodedText "?=" |
                                "=?" Charset "?" Encoding "?" EncodedText "?="
                                
Encoding                =      [Q q] | [B b]

Charset                 =      "utf-8" |
                                "US-ASCII" |
                                "Big5" |
                                "EUC-JP" |
                                "EUC-KR" |
                                "GB2312" |
                                "ISO-2022-JP" |
                                "ISO-2022-JP-2" |
                                "ISO-2022-KR" |
                                "ISO-8859-1" |
                                "ISO-8859-10" |
                                "ISO-8859-2" |
                                "ISO-8859-3" |
                                "ISO-8859-4" |
                                "ISO-8859-5" |
                                "ISO-8859-6" |
                                "ISO-8859-6-E" |
                                "ISO-8859-6-I" |
                                "ISO-8859-7" |
                                "ISO-8859-8" |
                                "ISO-8859-8-E" |
                                "ISO-8859-8-I" |
                                "ISO-8859-9" |
                                "KOI8-R" |
                                "Shift_JIS"

Language                =      PrimarySubtag ("-" Subtag)*
EncodedText             =      (!["?"] ( Alpha | Digit | Symbol ))+
PrimarySubtag           =      Alpha Alpha? Alpha? Alpha? Alpha? Alpha? Alpha? Alpha?
Subtag                  =      AlphaNum AlphaNum? AlphaNum? AlphaNum? AlphaNum? AlphaNum? AlphaNum? AlphaNum?
                            
# May need to be updated - this is ancient
UTF8Octets          =      UTF8Char*
UTF8Char            =      UTF8_1 | UTF8_2 | UTF8_3 | UTF8_4
UTF8_1              =      [\000-\177]
UTF8_2              =      [\302-\337] UTF8Tail
UTF8_3              =      [\340] [\240-\277] UTF8Tail | 
                            [\341-\354] UTF8Tail UTF8Tail |
                            [\355] [\200-\237] UTF8Tail | 
                            [\356-\357] UTF8Tail UTF8Tail
UTF8_4              =      [\360] [\220-\277] UTF8Tail UTF8Tail | [\361-\363] UTF8Tail UTF8Tail UTF8Tail |
                            [\364] [\200-\217] UTF8Tail UTF8Tail
UTF8Tail            =      [\200-\277]

RFCWord             =      Atom | QuotedString
Phrase              =      RFCWord+ | ObsPhrase
ObsPhrase           =      RFCWord (RFCWord | "." | CFWS)*


# Atom (2822 - mostly for supported obsolete stuff)
AText               =      Alpha | Digit | 
                            "!" | "#" |   
                            "$" | "%" |   
                            "&" | "'" |
                            "*" | "+" |
                            "-" | "/" |
                            "=" | "?" |
                            "^" | "_" |
                            "`" | "{" |
                            "|" | "}" |
                            "~"
Atom                =       CFWS? AText+ CFWS?
DotAtom             =       CFWS? DotAtomText CFWS?
DotAtomText         =       AText+ ("." AText+)*

COLON_PLUS_WS       =       Whitespace* COLON Whitespace*
