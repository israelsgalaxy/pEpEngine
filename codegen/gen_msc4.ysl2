include yslt.yml2

tstylesheet {
    const "maxdepth", "15";
    const "mindepth", "4";

    const "true", "boolean(1)";
    const "false", "boolean(0)";

    const "_Devices" {
            device "a";
            device "b";
            device "c";
    }
    const "Devices", "exsl:node-set($_Devices)/*";

    key "stname", "state", "@name";

    template "/protocol" {

// This does need a third device in the chart.
// CannotDecrypt at Grouped now leads to GG->GG situation, but 
// should in the future also initiate a SGG->GGG situation.
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "thirdDeviceState", "'Sole'",
//        with "depth", "0",
//        with "message", "'CannotDecrypt'";

//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Sole'",
//        with "secondDeviceState", "'Sole'",
//        with "depth", "0",
//        with "message", "'CannotDecrypt'";

// This does need a third device in the chart (SGG->GGG)
    apply "/protocol/fsm[1]"
        with "whoAmI", "1",
        with "groupLeader", "2",
        with "firstDeviceState", "'Sole'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Grouped'",
        with "depth", "2",
        with "message", "'CannotDecrypt'";

//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "depth", "3",
//        with "message", "'CannotDecrypt'";

//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "depth", "4",
//        with "message", "'KeyGen'";

// This needs a third device in the chart: GGG->SGG
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "thirdDeviceState", "'Grouped'",
//        with "depth", "0",
//        with "message", "'LeaveDeviceGroup'";
    }

    template "action" {
        param "whoAmI";
        param "eol", "';'";
        |  «$Devices[$whoAmI]» rbox «$Devices[$whoAmI]» [label="«@name»"]«$eol»
    }

    template "/protocol/fsm[1]" {
        param "firstDeviceState";
        param "secondDeviceState";
        param "thirdDeviceState";
        param "whoAmI";
        param "groupLeader";
        param "message";
        param "depth";

        // Prepare MSC header
        const "msc" {
        ||
        # The entities
        u [label="User"], «$Devices[1]» [label="1st Device"], «$Devices[2]» [label="2nd Device"], «$Devices[3]» [label="3rd Device"];
    
        # Small gap before the boxes
        |||;
    
        # Next two on same line due to ','
        «$Devices[1]» box «$Devices[1]» [label="«$firstDeviceState»"],
        «$Devices[2]» box «$Devices[2]» [label="«$secondDeviceState»"],
        «$Devices[3]» box «$Devices[3]» [label="«$thirdDeviceState»"];
        ||
        const "Init1",  "count(/protocol/fsm[1]/state[@name=$firstDeviceState]/event[@name='Init']/action)";
        const "Init2",  "count(/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name='Init']/action)";
        const "Init3",  "count(/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name='Init']/action)";
        if "$Init1 >= 1" {
			| «$Devices[1]» rbox «$Devices[1]» [label="«/protocol/fsm[1]/state[@name=$firstDeviceState]/event[@name='Init']/action[1]/@name»"],
		}
        if "$Init2 >= 1" {
			| «$Devices[2]» rbox «$Devices[2]» [label="«/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name='Init']/action[1]/@name»"],
		}
        if "$Init3 >= 1" {
			| «$Devices[3]» rbox «$Devices[3]» [label="«/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name='Init']/action[1]/@name»"];
		}
        if "$Init1 >= 2" {
			| «$Devices[1]» rbox «$Devices[1]» [label="«/protocol/fsm[1]/state[@name=$firstDeviceState]/event[@name='Init']/action[2]/@name»"],
		}
        if "$Init2 >= 2" {
			| «$Devices[2]» rbox «$Devices[2]» [label="«/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name='Init']/action[2]/@name»"],
		}
        if "$Init3 >= 2" {
			| «$Devices[3]» rbox «$Devices[3]» [label="«/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name='Init']/action[2]/@name»"];
        }
        | u -> «$Devices[1]» [label="«$message»"];
            }
            const "auxStates" {
                state value "$firstDeviceState";
                state value "$secondDeviceState";
                state value "$thirdDeviceState";
            }
            apply "//state[@name=$firstDeviceState]/event[@name=$message]", 1
                    with "states", "exsl:node-set($auxStates)/*",
                    with "whoAmI", "$whoAmI",
                    with "groupLeader", "$groupLeader",
                    with "depth", "$depth",
                    with "return", "$false",
                    with "msc", "$msc";
    } //template

    template "protocol/fsm[1]/*/event" {
        param "states";
        param "whoAmI";
        param "groupLeader";
        param "msc";
        param "log";
        param "depth";
        param "return";

        // Some messages and transitions are conditional
        for ("descendant::condition|descendant::else") {
            // Include conditions in MSC
            const "newmsc" {
                | «$msc» 
                call "writeConditions" with "whoAmI", "$whoAmI";
            }
            call "prepare4nextStep"
                with "states", "$states",
                with "whoAmI", "$whoAmI",
                with "groupLeader", "$groupLeader",
                with "msc", "$newmsc",
                with "log", "$log",
                with "return", "$return",
                with "depth", "$depth";
        }
        // Some messages and transitions aren't conditional
        if "count(descendant::condition)=0" {
            call "prepare4nextStep"
                with "states", "$states",
                with "whoAmI", "$whoAmI",
                with "groupLeader", "$groupLeader",
                with "msc", "$msc",
                with "log", "$log",
                with "return", "$return",
                with "depth", "$depth";
        }
    } //template event

    // This is a function, which means it gets called with the previous event or a condition therein.
    function "prepare4nextStep" {
        param "states";
        param "whoAmI";
        param "groupLeader";
        param "msc";
        param "depth";
        param "return";
        param "log";

        const "event", "ancestor-or-self::event/@name";
        const "ownState", "ancestor::state/@name";
        // There can only be one transition, but we don't rely on uniqueness and take the first
        const "target", "child::transition[1]/@target";   
        // Include user actions in MSC
        const "eventString" if "/protocol/fsm[1]/external[@name=$event]" {
           | u -> «$Devices[$whoAmI]» [label="«$event»"];
                };
        const "do-before" {
            apply "child::send[1]/preceding-sibling::action" with "whoAmI", "$whoAmI";
        };
        const "do-after" {
            apply "child::send[1]/following-sibling::action" with "whoAmI", "$whoAmI";
        };
        const "do-without" {
            if "count(child::send)=0" {
                apply "child::action" with "whoAmI", "$whoAmI";
            }
        };
        const "do-init" {
            if "$target and not(/protocol/fsm[1]/state[@name=$target]/event[@name='Init']/send)" {
                apply "/protocol/fsm[1]/state[@name=$target]/event[@name='Init']/action" with "whoAmI", "$whoAmI";
            }
        };
        const "messageString" {
            for "child::send" {
                const "message", "@name";
                const "stateset", "//state";
                for "$Devices" {
                    const "rec", "position()";
                    const "state", "$states[$rec]";
                    const "receives", "boolean($stateset[@name=$state]/event[@name=$message])";
                    if "not($whoAmI=$rec) and $receives" {
                        | «$Devices[$whoAmI]» -> «$Devices[$rec]» [label="«$message»"];
                    }
                } 
            }
        };
        const "messageTest" {
            for "str:tokenize($messageString,'\n')" {
                > «contains($msc,.)» or
            }
            > false
        };
        const "thirdPartyStuff" {
            for "child::send" {
                const "message", "@name";
                // Originally this should only be used for messages that are understood only by third Device.
                // But at least CommitReject, Rollback and CommitAccept MUST be rendered by all receiptients.
                // So let's try to ditch the condition that no one else understands this message and try what'll happen.
                // Ok, didn't work out nicely.
                // Second guess: Allowlist messages.
                if "((not(//state[@name=$states[1]]/event[@name=$message]) or $whoAmI=1) and (not(//state[@name=$states[2]]/event[@name=$message]) or $whoAmI=2) or contains('CommitReject,CommitAccept,Rollback',$message)) and (boolean(//state[@name=$states[3]]/event[@name=$message]) and not($whoAmI=3))" {
                apply "//state[@name=$states[3]]/event[@name=$message]" 
                    with "states", "$states",
                    with "whoAmI", "3",
                    with "log", "$log",
                    with "depth", "$depth",
                    with "return", "$true";
                }
            }
        };
        const "thirdDeviceNewState", "substring-before($thirdPartyStuff,';;')";
        const "auxnewstates" {
            for "$states" {
                choose {
                    when "$whoAmI=position() and $target" state value "$target";
                    when "position()=3 and $thirdDeviceNewState!=''" state value "$thirdDeviceNewState";
                    otherwise state value ".";
                }
            }
        };
        const "newstates", "exsl:node-set($auxnewstates)/*";
        // The ground condition for the recursion is still ugly, but it's doing it's job.
//backup        const "stopCondition", "(((ancestor::state/@timeout='off' and not($target)) or //state[@name=$target]/@timeout='off') and not(child::send) and //state[@name=$states[2]]/@timeout='off' and //state[@name=$states[3]]/@timeout='off') or ($states[2]='End' and $states[3]='End' and $target='End') or $depth>$maxdepth";
        const "stopCondition", "(not(child::send) and (//state[@name=$newstates[1]]/@timeout='off' or $newstates[1]='End') and (//state[@name=$newstates[2]]/@timeout='off' or $newstates[2]='End') and (//state[@name=$newstates[3]]/@timeout='off' or $newstates[3]='End')) or $depth>$maxdepth";

        const "testmsc" {
            value "$msc";
            |   «$eventString»
            value "$do-before";
            value "$messageString";
            value "$do-after";
            value "$do-without";
            if "$target" |   «$Devices[$whoAmI]» box «$Devices[$whoAmI]»     [label="«$target»"];
            if "not($stopCondition)" value "$do-init";
        };
        // amend the log
        const "newlog" {
            const "condition", "ancestor-or-self::condition/@name";
            value "$log";
            | ----------------------------------------------------------------------------------
            | «$Devices[$whoAmI]»: at «$ownState» on «$event» if «$condition» send «child::send» go «$target» 
            for "$newstates" | «.»,
            |
//            | «not(child::send)» and «//state[@name=$newstates[1]]/@timeout='off'» and «//state[@name=$newstates[2]]/@timeout='off'» and «//state[@name=$newstates[3]]/@timeout='off'»
//           | «(not(child::send) and //state[@name=$newstates[1]]/@timeout='off' and //state[@name=$newstates[2]]/@timeout='off' and //state[@name=$newstates[3]]/@timeout='off')» or «($newstates[2]='End' and $newstates[3]='End' and $newstates[1]='End')» or «$depth>$maxdepth»
//backup           | «(((ancestor::state/@timeout='off' and not($target)) or //state[@name=$target]/@timeout='off') and not(child::send) and //state[@name=$states[2]]/@timeout='off' and //state[@name=$states[3]]/@timeout='off')» or «($states[2]='End' and $states[3]='End' and $target='End')» or «$depth>$maxdepth»
            | loop «$messageString!='' and contains($msc, $messageString)»
            | dead end «(not(child::send) and not($target) and not(child::action))»
            | send «boolean(child::send)»
            | stop «$stopCondition»
            | "«$thirdDeviceNewState»"
            | tps «$thirdPartyStuff»
//            value "$testmsc";
        };
        if "$return=$true" {
                | «$newstates[3]»;;
                value "$testmsc";
                | ###
        }
        if "not($return) or $return=$false" {
            const "cwd", ".";
            for "str:tokenize($thirdPartyStuff,'###')" {
                const "thirdDeviceMSC", "substring-after(.,';;')";
                for "$cwd" {
                call "nextStep"
                    with "whoAmI", "$whoAmI",
                    with "depth", "$depth",
                    with "stopCondition", "$stopCondition",
                    with "messageTest", "dyn:evaluate($messageTest)",
                    with "newstates", "$newstates",
                    with "target", "$target",
                    with "msc" { value "$testmsc"; value "$thirdDeviceMSC"; },
                    with "newlog", "$newlog";
                }
            } //for tokenize
            if "not($thirdPartyStuff) or $thirdPartyStuff=''" {
                call "nextStep"
                    with "whoAmI", "$whoAmI",
                    with "depth", "$depth",
                    with "stopCondition", "$stopCondition",
                    with "messageTest", "dyn:evaluate($messageTest)",
                    with "newstates", "$newstates",
                    with "target", "$target",
                    with "msc", "$testmsc",
                    with "newlog", "$newlog";
            }
        } //if return=false
    } //function prepare4nextStep

    function "nextStep" {
        param "whoAmI";
        param "depth";
        param "stopCondition";
        param "messageTest";
        param "newstates";
        param "target";
        param "msc";
        param "newlog";
        choose {
            // First check for ground conditions
            when "$stopCondition" {
                call "lastStep"
                    with "newlog", "$newlog",
                    with "target", "$target",
                    with "whoAmI", "$whoAmI",
                    with "states", "$newstates",
                    with "msc", "$msc",
                    with "depth", "$depth";
            }
            // Then check for abort condition(s)
            // First we check for loops.
            // In that case we print the log and go to another recursion path.
            when "$messageTest" {
                value "$newlog"
                | loop detected «$depth»
            }
            when "(not(child::send) and not($target) and not(child::action))" {
                value "$newlog"
                | no path ahead «$depth»
            }
            otherwise {
                if "boolean(child::send)" {
                    const "nextlog" {
                        value "$newlog";
                        |  b «$depth» 
                    };
                    for "child::send" {
                        const "message", "@name";
                        const "stateset", "/protocol/fsm[1]//state";
                        for "$Devices" {
                            const "rec", "position()";
                            const "state", "$newstates[$rec]";
                            const "receives", "boolean($stateset[@name=$state]/event[@name=$message])";
                            // Messages to third Device are already taken care of
                            if "not($whoAmI=$rec) and not($rec=3) and $receives" {
                                apply "$stateset[@name=$newstates[$rec]]/event[@name=$message]"
                                    with "states", "$newstates",
                                    with "whoAmI", "$rec",
                                    with "depth", "$depth+1",
                                    with "log", "$nextlog",
                                    with "msc", "$msc";
                            }
                        } 
                    }
                }
                if "$target and //state[@name=$target]/event[@name='Init']/send|//state[@name=$target]/event[@name='Init']/transition" {
                    const "nextlog" {
                        value "$newlog";
                        | «$target» and «count(//state[@name=$target]/event[@name='Init']/send)»
                        | Init needed at «$target»(«$Devices[$whoAmI]»)
                    }
                    apply "/protocol/fsm[1]/state[@name=$newstates[$whoAmI]]/event[@name='Init']"
                        with "states", "$newstates",
                        with "whoAmI", "$whoAmI",
                        with "depth", "$depth+1",
                        with "log", "$nextlog",
                        with "msc", "$msc";
                }
                if "$target and not(//state[@name=$target]/event[@name='Init']/send|//state[@name=$target]/event[@name='Init']/transition)" {
                    call "nexternal"
                        with "states", "$newstates",
                        with "whoAmI", "$whoAmI",
                        with "depth", "$depth+1",
                        with "log", "$newlog",
                        with "msc", "$msc",
                        with "target", "$newstates[$whoAmI]";
                }
            }
        } //choose
    } //function nextStep

    function "lastStep" {
        param "newlog";
        param "target";
        param "whoAmI";
        param "states";
        param "msc";
        param "depth";
        const "ownState", "$states[$whoAmI]";
        // We generate a hopefully unique filename from random numbers
        const "secid", "math:random()";
        const "id", "concat(generate-id(),substring($secid,3,6))";
        // For the footer of the MSC
        const "stateString" choose {
            when ("$target and not($target=$ownState)") {
            |    «$Devices[$whoAmI]» box «$Devices[$whoAmI]» [label="«$target»"],
            }
            otherwise {
            |    «$Devices[$whoAmI]» box «$Devices[$whoAmI]» [label="«$ownState»"],
            }
        };
        // We write the log
        | ===========================================================================
        | doc «$depth», «$id»:
        value "$newlog";
        | STOP
        // and write the finished MSC into a text file
        document "msc/{$id}.msc" method="text" {
            | msc {
            |    «$msc»
            value "$stateString";
            for "$Devices" {
                const "pos", "position()";
                if "not(position()=$whoAmI)" {
                    |    «$Devices[$pos]» box «$Devices[$pos]» [label="«$states[$pos]»"]
                    choose {
                        when "$pos=3" > ;
                        otherwise > ,
                    }
                }
            }
            | }
        }
    } //function lastStep

    // A helper function to write conditional clauses into the MSC
    function "writeConditions" {
        param "whoAmI";
        for ("ancestor-or-self::condition|ancestor-or-self::else") {
            const "name" {
                choose {
                    // are we in the if clause
                    when "@name" 
                        value "@name";
                    // or are we in the else clause
                    otherwise
                        > not «preceding-sibling::condition/@name»
                }
            }
                | «$Devices[$whoAmI]» abox «$Devices[$whoAmI]» [label="«$name»"];
        }
    }

    // Because we need this more than once:
    function "nexternal" {
        param "states";
        param "whoAmI";
        param "depth";
        param "log";
        param "msc";
        param "target";
        const "stateset", "/protocol/fsm[1]/state";
//        if "$whoAmI<3" {
        for "$states" {
            const "state", ".";
            const "pos", "position()";
            for "$stateset[@name=$state]/event" {
                const "name", "@name";
                if "boolean(/protocol/fsm[1]/external[@name=$name]) and $pos!=3" {
                    const "newlog" {
                        value "$log"
                        | nexternal «$name» at «$state»
                    }
                    apply "."
                        with "whoAmI", "$pos",
                        with "states", "$states",
                        with "depth", "$depth+1",
                        with "log", "$newlog",
                        with "msc", "$msc";
                }
            }
        }
//        }
    }
} //tstylesheet

