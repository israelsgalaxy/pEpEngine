include yslt.yml2

tstylesheet {
    const "maxdepth", "15";
    const "mindepth", "4";

    const "_Devices" {
            device "'a'";
            device "'b'";
            device "'c'";
    }
    const "Devices", "exsl:node-set($_Devices)/*";

    key "stname", "state", "@name";

    template "/protocol" {

// This does need a third device in the chart.
// CannotDecrypt at Grouped now leads to GG->GG situation, but 
// should in the future also initiate a SGG->GGG situation.
    apply "/protocol/fsm[1]"
        with "whoAmI", "1",
        with "groupLeader", "2",
        with "firstDeviceState", "'Grouped'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Sole'",
        with "depth", "0",
        with "message", "'CannotDecrypt'";

    apply "/protocol/fsm[1]"
        with "whoAmI", "1",
        with "groupLeader", "2",
        with "firstDeviceState", "'Sole'",
        with "secondDeviceState", "'Sole'",
        with "depth", "0",
        with "message", "'CannotDecrypt'";

// This does need a third device in the chart (SGG->GGG)
    apply "/protocol/fsm[1]"
        with "whoAmI", "1",
        with "groupLeader", "2",
        with "firstDeviceState", "'Sole'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Grouped'",
        with "depth", "2",
        with "message", "'CannotDecrypt'";

//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "depth", "3",
//        with "message", "'CannotDecrypt'";

//    apply "/protocol/fsm[1]"
//        with "whoAmI", "1",
//        with "groupLeader", "2",
//        with "firstDeviceState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "depth", "4",
//        with "message", "'KeyGen'";

// This needs a third device in the chart: GGG->SGG
    apply "/protocol/fsm[1]"
        with "whoAmI", "1",
        with "groupLeader", "2",
        with "firstDeviceState", "'Grouped'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Grouped'",
        with "depth", "0",
        with "message", "'LeaveDeviceGroup'";
    }

    template "action" {
        param "whoAmI";
        param "eol", "';'";
        |  «$whoAmI» rbox «$whoAmI» [label="«@name»"]«$eol»
    }

    template "/protocol/fsm[1]" {
        param "firstDeviceState";
        param "secondDeviceState";
        param "thirdDeviceState";
        param "whoAmI";
        param "groupLeader";
        param "message";
        param "depth";

        // Prepare MSC header
        const "msc" {
        ||
        # The entities
        u [label="User"], «$Devices[1]» [label="1st Device"], «$Devices[2]» [label="2nd Device"], «$Devices[3]» [label="3rd Device"];
    
        # Small gap before the boxes
        |||;
    
        # Next two on same line due to ','
        «$Devices[1]» box «$Devices[1]» [label="«$firstDeviceState»"],
        «$Devices[2]» box «$Devices[2]» [label="«$secondDeviceState»"],
        «$Devices[3]» box «$Devices[3]» [label="«$thirdDeviceState»"];
        ||
        const "Init1",  "count(/protocol/fsm[1]/state[@name=$firstDeviceState]/event[@name='Init']/action)";
        const "Init2",  "count(/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name='Init']/action)";
        const "Init3",  "count(/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name='Init']/action)";
        if "$Init1 >= 1" | «$Devices[1]» rbox «$Devices[1]» [label="«/protocol/fsm[1]/state[@name=$firstDeviceState]/event[@name='Init']/action[1]/@name»"],
        if "$Init2 >= 1" | «$Devices[2]» rbox «$Devices[2]» [label="«/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name='Init']/action[1]/@name»"],
        if "$Init3 >= 1" | «$Devices[3]» rbox «$Devices[3]» [label="«/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name='Init']/action[1]/@name»"];
        if "$Init1 >= 2" | $Devices[1]» rbox «$Devices[1]» [label="«/protocol/fsm[1]/state[@name=$firstDeviceState]/event[@name='Init']/action[2]/@name»"],
        if "$Init2 >= 2" | $Devices[2]» rbox «$Devices[2]» [label="«/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name='Init']/action[2]/@name»"],
        if "$Init3 >= 2" | $Devices[3]» rbox «$Devices[3]» [label="«/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name='Init']/action[2]/@name»"];
        | u -> «$Devices[1]» [label="«$message»"];
            }
            const "auxStates" {
                state value "$firstDeviceState";
                state value "$secondDeviceState";
                state value "$thirdDeviceState";
            }
            apply "//state[@name=$firstDeviceState]/event[@name=$message]", 1
                    with "states", "exsl:node-set($auxStates)/*",
                    with "whoAmI", "$whoAmI",
                    with "groupLeader", "$groupLeader",
                    with "depth", "$depth",
                    with "return", "false",
                    with "msc", "$msc";
    } //template

    template "protocol/fsm[1]/*/event" {
        param "states";
        param "whoAmI";
        param "groupLeader";
        param "msc";
        param "log";
        param "depth";
        param "return";

        // Some messages and transitions are conditional
        for ("descendant::condition|descendant::else") {
            // Include conditions in MSC
            const "newmsc" {
                | «$msc» 
                call "writeConditions" with "whoAmI", "$whoAmI";
            }
            call "nextStep"
                with "states", "$states",
                with "whoAmI", "$whoAmI",
                with "groupLeader", "$groupLeader",
                with "msc", "$newmsc",
                with "log", "$log",
                with "return", "false",
                with "depth", "$depth";
        }
        // Some messages and transitions aren't conditional
        if "count(descendant::condition)=0" {
            call "nextStep"
                with "states", "$states",
                with "whoAmI", "$whoAmI",
                with "groupLeader", "$groupLeader",
                with "msc", "$msc",
                with "log", "$log",
                with "return", "false",
                with "depth", "$depth";
        }
    } //template event

    // This is a function, which means it gets called with the previous event or a condition therein.
    function "nextStep" {
        param "states";
        param "whoAmI";
        param "groupLeader";
        param "msc";
        param "depth";
        param "return";
        param "log";

        const "event", "ancestor-or-self::event/@name";
        const "ownState", "ancestor::state/@name";
        // There can only be one transition, but we don't rely on uniqueness and take the first
        const "target", "child::transition[1]/@target";   
        // Include user actions in MSC
        const "eventString" if "/protocol/fsm[1]/external[@name=$event]" {
           | u -> «$Devices[$whoAmI]» [label="«$event»"];
                };
        const "do-before" {
            apply "child::send[1]/preceding-sibling::action" with "whoAmI", "$whoAmI";
        }
        const "do-after" {
            apply "child::send[1]/following-sibling::action" with "whoAmI", "$whoAmI";
        }
        const "do-without" {
            if "count(child::send)=0" {
                apply "child::action" with "whoAmI", "$whoAmI";
            }
        }
        const "do-init" {
            if "$target and not(/protocol/fsm[1]/state[@name=$target]/event[@name='Init']/send)" {
                apply "/protocol/fsm[1]/state[@name=$target]/event[@name='Init']/action" with "whoAmI", "$whoAmI";
            }
        }
        const "messageString" {
            for "child::send" {
                const "message", "@name";
                const "stateset", "//state";
                for "$Devices" {
                    const "rec", "position()";
                    const "state", "$states[$rec]";
                    const "receives", "boolean($stateset[@name=$state]/event[@name=$message])";
                    if "not($whoAmI=$rec) and $receives" {
                        | «$Devices[$whoAmI]» -> «$Devices[$rec]» [label="«$message»"];
                    }
                } 
            }
        }
        // The ground condition for the recursion is still ugly, but it's doing it's job.
        const "stopCondition", "(((ancestor::state/@timeout='off' and not($target)) or //state[@name=$target]/@timeout='off') and not(child::send) and //state[@name=$states[2]]/@timeout='off' and //state[@name=$states[3]]/@timeout='off') or ($states[2]='End' and $states[3]='End' and $target='End') or $depth>$maxdepth";

        // amend the log
        const "newlog" {
            const "condition", "ancestor-or-self::condition/@name";
            value "$log";
            | ----------------------------------------------------------------------------------
            | «$whoAmI»: at «$ownState» on «$event» if «$condition» send «child::send» go «$target» 
            value "$states";
            | 
            | «(((ancestor::state/@timeout='off' and not($target)) or //state[@name=$target]/@timeout='off') and not(child::send) and //state[@name=$states[2]]/@timeout='off' and //state[@name=$states[3]]/@timeout='off')» or «($states[2]='End' and $states[3]='End' and $target='End')» or «$depth>$maxdepth»
            | stop «$stopCondition»
        };
        const "newstates" {
            for "$states" {
                choose {
                    when "$whoAmI=position() and $target" state value "$target";
                    otherwise state value ".";
                }
            }
        }
        const "testmsc" {
            value "$msc";
            |   «$eventString»
            value "$do-before";
            value "$messageString";
            value "$do-after";
            value "$do-without";
            if "$target" |   «$whoAmI» box «$whoAmI»     [label="«$target»"];
            value "$do-init";
//            for message that is only understood by thirdDevice {
//                const "message", "@name";
//                const "statename", "$states[3]";
//                apply "//state[@name=$statename]/event[@name=$message]" {
//                    with "states", "exsl:node-set($newstates)/*",
//                    with "whoAmI", "$Devices[3]",
//                    with "log", "$log",
//                    with "depth", "$depth",
//                    with "return", "true";
//            }
        }
        choose {
            // First check for abort condition(s)
            // Now we only check for loops.
            // In that case we print the log and go to another recursion path.
            when "contains($msc, $messageString) or (not(child::send) and not($target) and not(child::action))" {
                value "$newlog"
                | loop detected «$depth»
            }
            // Then for ground conditions
            when "$stopCondition" {
                const "newmsc", "$testmsc";
                call "lastStep"
                    with "newlog", "$newlog",
                    with "target", "$target",
                    with "whoAmI", "$whoAmI",
                    with "states", "$states",
                    with "msc", "$newmsc",
                    with "depth", "$depth";
            }
            when "child::send" {
                const "nextlog" {
                    value "$newlog";
                    |  b «$depth» 
                };
                const "newmsc", "$testmsc";
                for "child::send" {
                    const "message", "@name";
                    const "stateset", "/protocol/fsm[1]//state";
                    for "$Devices" {
                        const "rec", "position()";
                        const "state", "$states[$rec]";
                        const "receives", "boolean($stateset[@name=$state]/event[@name=$message])";
                        // Messages to third Device are already taken care of
                        if "not($whoAmI=$rec) and not($rec=3) and $receives" {
                            apply "$stateset[@name=$states[$rec]]/event[@name=$message]"
                                with "states", "exsl:node-set($newstates)/*",
                                with "whoAmI", "$groupLeader",
                                with "depth", "$depth+1",
                                with "log", "$nextlog",
                                with "msc", "$newmsc";
                        }
                    } 
                }
            }
        } //choose
        if "not($stopCondition)" {
                 call "nexternal"
                    with "states", "exsl:node-set($newstates)/*",
                    with "whoAmI", "$whoAmI",
                    with "depth", "$depth+1",
                    with "log", "$newlog",
                    with "msc", "$testmsc",
                    with "target", "$target";
        }
    } //function nextStep

//    function "thirdDeviceEvent" {
//        param "event";
//        param "firstDevice";
//        param "firstDeviceState";
//        param "secondDeviceState";
//        param "thirdDeviceState";
//        param "groupLeader";
//        param "thirdDevice";
//        for "/protocol/fsm[1]/state[@name=$thirdDeviceState]/event[@name=$event]" {
//            for ("descendant::condition|descendant::else") {
//        | «$firstDevice» box «$thirdDevice» [label="Hey!"];
//                call "writeConditions" with "whoAmI", "$thirdDevice";
//                // There can only be one transition, but we don't rely on uniqueness and take the first
//                const "target", "child::transition[1]/@target";
//                // before, after and without point to $message
//                const "do-before" {
//                    apply "child::send[1]/preceding-sibling::action" with "whoAmI", "$thirdDevice";
//                }
//                const "do-after" {
//                    apply "child::send[1]/following-sibling::action" with "whoAmI", "$thirdDevice";
//                }
//                const "do-without" {
//                    if "count(child::send)=0" {
//                        apply "child::action" with "whoAmI", "$thirdDevice";
//                    }
//                }
//                const "do-init" {
//                    if "$target" {
//                        apply "/protocol/fsm[1]/state[@name=$target]/event[@name='Init']/action" with "whoAmI", "$thirdDevice";
//                    }
//                }
//                value "$do-before";
//                value "$do-without";
//                for "child::send" {
//                    |   «$thirdDevice» -> «$groupLeader»,
//                    |   «$thirdDevice» -> «$firstDevice» [label="«@name»"];
//                }
//                value "$do-after";
//                if "$target" |    «$thirdDevice» box «$thirdDevice» [label="«$target»"];
//                value "$do-init";
//            }
//        }
//    }


    function "lastStep" {
        param "newlog";
        param "target";
        param "whoAmI";
        param "states";
        param "msc";
        param "depth";
        const "ownState", "$states[$whoAmI]";
        // We generate a hopefully unique filename from random numbers
        const "secid", "math:random()";
        const "id", "concat(generate-id(),substring($secid,3,6))";
        // For the footer of the MSC
        const "stateString" choose {
            when ("$target and not($target=$ownState)") {
            |    «$whoAmI» box «$whoAmI» [label="«$target»"],
            }
            otherwise {
            |    «$whoAmI» box «$whoAmI» [label="«$ownState»"],
            }
        };
        // We write the log
        | ===========================================================================
        | doc «$depth», «$id»:
        value "$newlog";
        | STOP
        // and write the finished MSC into a text file
        document "msc/{$id}.msc" method="text" {
            | msc {
            |    «$msc»
            value "$stateString";
            for "$Devices" {
                if "not(position()=$whoAmI)" |    «$Devices[position()]» box «$Devices[position()]» [label="«$states[position()]»"];
            }
            | }
        }
    } //function lastStep

    // A helper function to write conditional clauses into the MSC
    function "writeConditions" {
        param "whoAmI";
        for ("ancestor-or-self::condition|ancestor-or-self::else") {
            const "name" {
                choose {
                    // are we in the if clause
                    when "@name" 
                        value "@name";
                    // or are we in the else clause
                    otherwise
                        > not «preceding-sibling::condition/@name»
                }
            }
                | «$whoAmI» abox «$whoAmI» [label="«$name»"];
        }
    }

    // Because we need this more than once:
    function "nexternal" {
        param "states";
        param "whoAmI";
        param "depth";
        param "log";
        param "msc";
        param "target";
        for "/protocol/fsm[1]/state[@name=$target]/event" {
            const "name", "@name";
            if "boolean(/protocol/fsm[1]/external[@name=$name])" {
                apply "."
                    with "whoAmI", "$whoAmI",
                    with "states", "$states",
                    with "depth", "$depth+1",
                    with "log", "$log",
                    with "msc", "$msc";
            }
        }
    }
} //tstylesheet

