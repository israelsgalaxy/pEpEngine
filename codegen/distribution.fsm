// This file is under BSD License 2.0

// Distribution protocol for p≡p
// Copyright (c) 2019-2021, p≡p foundation

// Written by Volker Birk, Hartmut Goebel

include ./fsm.yml2

protocol Distribution 2 {

    // this protocol is stateless
    fsm KeyReset 1 {
        version 1, 0;

        message Commands 2 {
            auto Version version;
            list Command commandlist {
                field Identity ident;
                field Hash newkey;
            }
        }
    }

    // this protocol is stateless
    fsm ManagedGroup 2 {
        version 1, 0;

        message GroupInvite 2, security=untrusted {
            field Identity groupIdentity;
            field Identity manager;
        }

        message GroupAdopted 3, security=untrusted {
            field Identity groupIdentity;
            field Identity member;
        }

        message GroupDissolve 4, security=untrusted {
            field Identity groupIdentity;
            field Identity manager;
        }
    }

    fsm Exploration 3 {
        version 1, 0;

        message ExploreRequest 2, security=unencrypted {
            field TID challenge;
            field Identity forward;
        }

        message ExploreAnswer 3, security=untrusted {
            field TID challenge;
            field Identity forward;
            field Identity back;
        }

        message ExploreChallenge 4, security=untrusted {
            field TID challenge;
            field Identity forward;
            field Identity back;
        }

        message ExploreResponse 5, security=untrusted {
            field TID challenge;
            field Identity forward;
            field Identity back;
        }
    }

    // this protocol implements a 4-way handshake
    fsm TempKeyAgreement 4 {
        version 1, 0;

        state InitState {
            on Init {
                // Send suggestion as soon as we start. If the FSM was
                // started by a suggestion received from the comm-partner,
                // this will send out our suggestion even before processing
                // the received one, leveraging the cases whether we or the
                // comm-parnter started the agreement.
                go StartingAgreement;
            }

            on Start {
               // Dummy event. This is required to have some event which
               // can be send to the FSM to "start".
               // For initializing the TempKeyAgreement protocol from our side,
               // we need to start the FSM for the desired comm-partner.
               // Starting the FSM will immediately send out the suggestions
               // (see above). Anyhow, this separate event enables the upper
               // layers of the implementation to exclicitly start a
               // TempKeyAgreement protocol as needed.
               go StartingAgreement;
               }
        }

        state StartingAgreement {
            on Init {
                do computeSuggestion;
                send Suggestion;
            }

            on Suggestion { // from the comm-partner
                do computeTemporaryKey;
                send TemporaryKey;
                go SuggestionReceived;
            }

            // for robustness
            on TemporaryKey { // from the comm-partner
                go StartingAgreement;
            }

            on Reset {  // event
                go StartingAgreement;
            }

        }

        state SuggestionReceived {
            on TemporaryKey { // from the comm-partner
                if isSameTemporaryKey {
                    go Established;
                }
                else {  // for robustness
                    go StartingAgreement;
                }
            }

            // TODO: Suggestion

            on Reset {  // event
                go StartingAgreement;
            }
        }

        state Established {
            on Init {
                do configureTemporaryKey;
            }

            on Suggestion {
                // TODO: rethink
                do computeTemporaryKey;
                send TemporaryKey;
                go SuggestionReceived;
            }

            // for robustness
            on TemporaryKey {
                go StartingAgreement;
            }

            on Reset {  // event
                go StartingAgreement;
            }
        }

        message Suggestion 2 {
            field Hash suggestion;
        }
        message TemporaryKey 3 {
            field Hash key;   // key to be ack'ed
        }
    }
}
