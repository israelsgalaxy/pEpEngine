// This file is under BSD License 2.0

// Distribution protocol for p≡p
// Copyright (c) 2019-2021, p≡p foundation

// Written by Volker Birk, Hartmut Goebel

include ./fsm.yml2

protocol Distribution 2 {

    // this protocol is stateless
    fsm KeyReset 1 {
        version 1, 0;

        message Commands 2 {
            auto Version version;
            list Command commandlist {
                field Identity ident;
                field Hash newkey;
            }
        }
    }

    // this protocol is stateless
    fsm ManagedGroup 2 {
        version 1, 0;

        message GroupInvite 2, security=untrusted {
            field Identity groupIdentity;
            field Identity manager;
        }

        message GroupAdopted 3, security=untrusted {
            field Identity groupIdentity;
            field Identity member;
        }

        message GroupDissolve 4, security=untrusted {
            field Identity groupIdentity;
            field Identity manager;
        }
    }

    fsm Exploration 3 {
        version 1, 0;

        message ExploreRequest 2, security=unencrypted {
            field TID challenge;
            field Identity forward;
        }

        message ExploreAnswer 3, security=untrusted {
            field TID challenge;
            field Identity forward;
            field Identity back;
        }

        message ExploreChallenge 4, security=untrusted {
            field TID challenge;
            field Identity forward;
            field Identity back;
        }

        message ExploreResponse 5, security=untrusted {
            field TID challenge;
            field Identity forward;
            field Identity back;
        }
    }

    // This protocol is stateful.  It is asymmetric, with no handshake.
    //
    // This specification contains more comments than it would be reasonable in
    // an ordinary protocol, but I am annotating this very heavily in order to
    // understand better myself -- this will also presumably serve as a decent
    // introductions to other beginners coming after me -- positron.
    fsm TempKeyAgreement 4 {
        version 1, 0;

        // By convention we do not do actual work in InitState.  This is cosmetic.
        state InitState {
            on Init {
                go BeforeAgreement;
            }
        }

        // This state serves to find the role for the following.  There are two roles,
        // * "initiator";
        // * "contactee".
        state BeforeAgreement timeout=off {
            on InitiateTKA { // this is called by the Initiator side
                             // InitiateTKA is an external event, not a message.  This is the default,
                             // since the name is never used for a message.
                // The "go" part must be the last: the statements in the action are executed sequentially,
                // imperative-style.
                go InitiateAgreement;
            }
            on StartAgreement { // here the role is Contactee
                go BeingContacted;
            }
        }

        // Here we are the initiator.
        state InitiateAgreement { // there is no timeout=off: this is a transitional state
            on Init {
                do computeSuggestion; // actions are implemented as hand-written C function,
                                      // with access to the I/O buffer
                send SuggestionFromInitiator; // by convention in this system send never fails; however
                                              // receive can fail.
            }
            on SuggestionFromContactee {
                do setTemporaryKey;
                do invokeCallback;
                go BeforeAgreement; // the roles can change then.
            }
            on InitiateTKA // this is an external event: it can happen in any state
                ; // ";" means empty body.  We do nothing: if we are in this state we already
                  // computed and sent a suggestion
        }

        // Here we are the contactee.
        state BeingContacted { // there is no timeout=off: this is a transitional state
            on Init {
                do computeSuggestion;
                send SuggestionFromContactee;
            }
            on SuggestionFromInitiator {
                do setTemporaryKey;
                do invokeCallback;
                go BeforeAgreement;
            }
            on InitiateTKA { // role switch: contactee -> initiator, triggered by an
                             // external event coming from the application (not the net)
                go InitiateAgreement;
            }
        }

        message StartAgreement 2, security=unencrypted // obviously not the default: this must be
                                                       // specified for the first message which we
                                                       // want to send unecnrypted; otherwise the
                                                       // actual sending will be prevented on a
                                                       // non-green connection.
                                                       // (In locked mode even this would be rejected.)
                                                       {
            // backward-compatibility can be dangerous (downgrade attack vector) -- Of course
            // this is just a vector, not an actual existing flaw [modal logic can describe this]
            // -- The argument in favour of the version field is maintainability in the long term.
            auto Version version;
            // No other fields: the layer below (struct message) contains the public key,
            // which is the useful information being transmitted.  This is the first message
            // being sent.
        }

        message SuggestionFromInitiator 3 {
            field Hash suggestion;
        }
        message SuggestionFromContactee 4 {
            field Hash suggestion;
        }
        // Fields have unique names throughout each fsm file (i.e. throughout each protocol family):
        // A reappearing name represents *the same* field: same memory in the I/O buffer.  The I/O
        // buffer is a superset of all fields (however there is an I/O buffer per protcol).
        // Rationale: challenge/response protocols are common, and this makes them more convenient to
        // implement by just "replying", without setting a field.
    }
}
