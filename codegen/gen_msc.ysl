include yslt.yml2

tstylesheet {
    const "maxdepth", "15";
    const "mindepth", "4";

    template "/protocol" {
    const "whoAmI", "'a'";
    const "commPartner", "'b'";

// This does need a third device in the chart.
// CannotDecrypt at Grouped now leads to GG->GG situation, but 
// should in the future also initiate a SGG->GGG situation.
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "$whoAmI",
//        with "commPartner", "$commPartner",
//        with "ownState", "'Grouped'",
//        with "commPartnerState", "'Sole'",
//        with "depth", "0",
//        with "message", "'CannotDecrypt'";

    apply "/protocol/fsm[1]"
        with "whoAmI", "$whoAmI",
        with "commPartner", "$commPartner",
        with "ownState", "'Sole'",
        with "commPartnerState", "'Sole'",
        with "depth", "0",
        with "message", "'CannotDecrypt'";

// This does need a third device in the chart (SGG->GGG)
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "$whoAmI",
//        with "commPartner", "$commPartner",
//        with "ownState", "'Sole'",
//        with "commPartnerState", "'Grouped'",
//        with "depth", "2",
//        with "message", "'CannotDecrypt'";

    apply "/protocol/fsm[1]"
        with "whoAmI", "$whoAmI",
        with "commPartner", "$commPartner",
        with "ownState", "'Grouped'",
        with "commPartnerState", "'Grouped'",
        with "depth", "3",
        with "message", "'CannotDecrypt'";

    apply "/protocol/fsm[1]"
        with "whoAmI", "$whoAmI",
        with "commPartner", "$commPartner",
        with "ownState", "'Grouped'",
        with "commPartnerState", "'Grouped'",
        with "depth", "4",
        with "message", "'KeyGen'";

// This needs a third device in the chart: GGG->SGG
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "$whoAmI",
//        with "commPartner", "$commPartner",
//        with "ownState", "'Grouped'",
//        with "commPartnerState", "'Grouped'",
//        with "depth", "0",
//        with "message", "'LeaveDeviceGroup'";
    }

    template "/protocol/fsm[1]" {
        param "ownState";
        param "commPartnerState";
        param "whoAmI";
        param "commPartner";
        param "message";
        param "depth";

        // Prepare MSC header
        const "msc"
            ||
              # The entities
              u [label="User"], a [label="1st Device"], b [label="2nd Device"];
           
              # Small gap before the boxes
              |||;
           
              # Next two on same line due to ','
              «$whoAmI» box «$whoAmI» [label="«$ownState»"],
              «$commPartner» box «$commPartner» [label="«$commPartnerState»"];
              u -> «$whoAmI» [label="«$message»"];
            ||
            apply "//state[@name=$ownState]/event[@name=$message]", 1
                    with "commPartnerState", "$commPartnerState",
                    with "whoAmI", "$whoAmI",
                    with "commPartner", "$commPartner",
                    with "depth", "$depth",
                    with "msc", "$msc";
    } //template

    template "protocol/fsm[1]/*/event" {
        param "commPartnerState";
        param "whoAmI";
        param "commPartner";
        param "msc";
        param "log";
        param "depth";

        // Some messages and transitions are conditional
        for ("descendant::condition|descendant::else") {
            // Include conditions in MSC
            const "newmsc" {
                | «$msc» 
                call "writeConditions" with "whoAmI", "$whoAmI";
            }
            call "nextStep"
                with "commPartnerState", "$commPartnerState",
                with "whoAmI", "$whoAmI",
                with "commPartner", "$commPartner",
                with "msc", "$newmsc",
                with "log", "$log",
                with "depth", "$depth";
        }
        // Some messages and transitions aren't conditional
        call "nextStep"
            with "commPartnerState", "$commPartnerState",
            with "whoAmI", "$whoAmI",
            with "commPartner", "$commPartner",
            with "msc", "$msc",
            with "log", "$log",
            with "depth", "$depth";
    } //template event

    // This is a function, which means it gets called with the previous event or a condition therein.
    function "nextStep" {
        param "commPartnerState";
        param "whoAmI";
        param "commPartner";
        param "msc";
        param "depth";
        param "log";
        const "event", "ancestor-or-self::event/@name";
        const "ownState", "ancestor::state/@name";
        // Include user actions in MSC
        const "eventString" if "/protocol/fsm[1]/external[@name=$event]" {
           | u -> «$whoAmI» [label="«$event»"];
                };
        // This is the message we're going to send
        // Yes, we only take the first one for now. 
        // If there are multiple messages sent at the same time, 
        // they are sent to different receipients, which we don't parse atm anyways.
        const "message", "child::send[1]/@name";
        // This is here only for the log:
        const "condition", "ancestor-or-self::condition/@name";
        // There can only be one transition, but we don't rely on uniqueness and take the first
        const "target", "child::transition[1]/@target";   
        // The ground condition for the recursion is still ugly, but it's doing it's job.
        // I'd like to get rid of that depth stuff and find a better condition for a stop
        // for sequences without transitions.
        const "stopCondition", "(((ancestor::state/@timeout='off' and not($target)) or //state[@name=$target]/@timeout='off') and //state[@name=$commPartnerState]/@timeout='off' and $depth>$mindepth) or $depth>$maxdepth or ($commPartnerState='End' and $target='End')";
//and //state[@name=$commPartnerState]/@timeout='off'

        // amend the log
        const "newlog" {
         value "$log";
         | ----------------------------------------------------------------------------------
         | «$whoAmI»: at «$ownState» on «$event» if «$condition» send «$message» go «$target» 
         | «$commPartner»: «$commPartnerState»
         | stop «//state[@name=$ownState]/@timeout» and  «//state[@name=$commPartnerState]/@timeout» and «$depth»>«$mindepth»
         | stop «$stopCondition»
        };
        // Here we prepare a search string for loop detection
        const "search" {
            | «$whoAmI» -> «$commPartner» [label="«$message»"];
        };
        choose {
            // First check for abort condition(s)
            // Now we only check for loops.
            // In that case we print the log and go to another recursion path.
            when "contains($msc, $search)" {
                value "$newlog"
                | loop detected «$depth»
            }
            // Then for ground conditions
            when "$stopCondition" {
                call "lastStep"
                    with "newlog", "$newlog",
                    with "target", "$target",
                    with "whoAmI", "$whoAmI",
                    with "ownState", "$ownState",
                    with "commPartnerState", "$commPartnerState",
                    with "commPartner", "$commPartner",
                    with "msc", "$msc",
                    with "depth", "$depth";
            }
            // Then choose the path to proceed
            // In case we send a message but don't change our own state
            when "$message and ($target=$ownState or not($target))" {
                const "newmsc" {
                    value "$msc";
                    |   «$eventString»
                    |   «$whoAmI» -> «$commPartner» [label="«$message»"];
                };
                const "nextlog" {
                    value "$newlog";
                    |  b «$depth» 
                };
                apply "/protocol/fsm[1]/state[@name=$commPartnerState]/event[@name=$message]"
                    with "commPartnerState", "$ownState",
                    with "whoAmI", "$commPartner",
                    with "commPartner", "$whoAmI",
                    with "depth", "$depth+1",
                    with "log", "$nextlog",
                    with "msc", "$newmsc";
            }
            // In case we send a message and change our own state
            // Previously existence of $eventString was mandatory, not sure if it should
            when "$message and $target and not($target=$ownState)" {
                const "nextlog" {
                    value "$newlog";
                    |  c «$depth» , «$eventString»
                };
               const "newmsc" {
                    value "$msc";
                    |   «$eventString»
                    |   «$whoAmI» -> «$commPartner» [label="«$message»"];
                    |   «$whoAmI» box «$whoAmI»     [label="«$target»"];
                };
                apply "/protocol/fsm[1]/state[@name=$commPartnerState]/event[@name=$message]"
                    with "commPartnerState", "$target",
                    with "whoAmI", "$commPartner",
                    with "commPartner", "$whoAmI",
                    with "depth", "$depth+1",
                    with "log", "$nextlog",
                    with "msc", "$newmsc";
            }
            // In case we send nothing but change our state and wait for user input
            when "not($message) and $target and not($target=$ownState)" {
                const "nextlog" {
                    value "$newlog";
                    |  d «$depth», «$eventString»
                };
                const "newmsc" {
                    value "$msc";
                    |   «$eventString»
                    |   «$whoAmI» box «$whoAmI» [label="«$target»"];
                };
                // Use every possible user input
                for "/protocol/fsm[1]/state[@name=$target]/event" {
                    const "name", "@name";
                    if "boolean(/protocol/fsm[1]/external[@name=$name])" {
                        apply "."
                            with "commPartnerState", "$commPartnerState",
                            with "whoAmI", "$whoAmI",
                            with "commPartner", "$commPartner",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc";
                    }
                }
            }
            // This should never be entered
            otherwise {
                value "$newlog"
                | o «$depth»
            }
        } //choose
    } //function nextStep


    function "lastStep" {
        param "newlog";
        param "target";
        param "whoAmI";
        param "ownState";
        param "commPartnerState";
        param "commPartner";
        param "msc";
        param "depth";
        // We generate a hopefully unique filename from random numbers
        const "secid", "math:random()";
        const "id", "concat(generate-id(),substring($secid,3,6))";
        // For the footer of the MSC
        const "stateString" choose {
            when ("$target and not($target=$ownState)") {
            |    «$whoAmI» box «$whoAmI» [label="«$target»"],
            }
            otherwise {
            |    «$whoAmI» box «$whoAmI» [label="«$ownState»"],
            }
        };
        // We write the log
        | ===========================================================================
        | doc «$depth», «$id»:
        value "$newlog";
        | STOP
        // and write the finished MSC into a text file
        document "msc/{$id}.msc" method="text" {
            | msc {
            |    «$msc»
            value "$stateString";
            |    «$commPartner» box «$commPartner» [label="«$commPartnerState»"];
            | }
        }
    } //function lastStep

    // A helper function to write conditional clauses into the MSC
    function "writeConditions" {
        param "whoAmI";
        for ("ancestor-or-self::condition|ancestor-or-self::else") {
            const "name" {
                choose {
                    // are we in the if clause
                    when "@name" 
                        value "@name";
                    // or are we in the else clause
                    otherwise
                        > not «preceding-sibling::condition/@name»
                }
            }
                | «$whoAmI» abox «$whoAmI» [label="«$name»"];
        }
    }
} //tstylesheet

