include yslt.yml2

tstylesheet {
    const "maxdepth", "15";
    const "mindepth", "4";

    template "/protocol" {
    const "whoAmI", "'a'";
    const "secondDevice", "'b'";
    const "thirdDevice", "'c'";

// This does need a third device in the chart.
// CannotDecrypt at Grouped now leads to GG->GG situation, but 
// should in the future also initiate a SGG->GGG situation.
    apply "/protocol/fsm[1]"
        with "whoAmI", "$whoAmI",
        with "secondDevice", "$secondDevice",
        with "thirdDevice", "$thirdDevice",
        with "ownState", "'Grouped'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Sole'",
        with "depth", "0",
        with "message", "'CannotDecrypt'";

// This is handled by gen_msc2.ysl2 because the third device is 
// all but needed for this one.
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "$whoAmI",
//        with "secondDevice", "$secondDevice",
//        with "thirdDevice", "$thirdDevice",
//        with "ownState", "'Sole'",
//        with "secondDeviceState", "'Sole'",
//        with "thirdDeviceState", "'Sole'",
//        with "depth", "0",
//        with "message", "'CannotDecrypt'";

// This does need a third device in the chart (SGG->GGG)
    apply "/protocol/fsm[1]"
        with "whoAmI", "$whoAmI",
        with "secondDevice", "$secondDevice",
        with "thirdDevice", "$thirdDevice",
        with "ownState", "'Sole'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Grouped'",
        with "depth", "2",
        with "message", "'CannotDecrypt'";

// The third device is not really needed for those two, so
// we'll leave it for gen_msc2.ysl2 to deal with.
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "$whoAmI",
//        with "secondDevice", "$secondDevice",
//        with "thirdDevice", "$thirdDevice",
//        with "ownState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "thirdDeviceState", "'Grouped'",
//        with "depth", "3",
//        with "message", "'CannotDecrypt'";
//
//    apply "/protocol/fsm[1]"
//        with "whoAmI", "$whoAmI",
//        with "secondDevice", "$secondDevice",
//        with "thirdDevice", "$thirdDevice",
//        with "ownState", "'Grouped'",
//        with "secondDeviceState", "'Grouped'",
//        with "thirdDeviceState", "'Grouped'",
//        with "depth", "4",
//        with "message", "'KeyGen'";

// This needs a third device in the chart: GGG->SGG
    apply "/protocol/fsm[1]"
        with "whoAmI", "$whoAmI",
        with "secondDevice", "$secondDevice",
        with "thirdDevice", "$thirdDevice",
        with "ownState", "'Grouped'",
        with "secondDeviceState", "'Grouped'",
        with "thirdDeviceState", "'Grouped'",
        with "depth", "0",
        with "message", "'LeaveDeviceGroup'";
    }

    template "/protocol/fsm[1]" {
        param "ownState";
        param "secondDeviceState";
        param "thirdDeviceState";
        param "whoAmI";
        param "secondDevice";
        param "thirdDevice";
        param "message";
        param "depth";

        // Prepare MSC header
        const "msc"
            ||
              # The entities
              u [label="User"], a [label="1st Device"], b [label="2nd Device"], c [label="3rd Device"];
           
              # Small gap before the boxes
              |||;
           
              # Next two on same line due to ','
              «$whoAmI» box «$whoAmI» [label="«$ownState»"],
              «$secondDevice» box «$secondDevice» [label="«$secondDeviceState»"],
              «$thirdDevice» box «$thirdDevice» [label="«$thirdDeviceState»"];
              u -> «$whoAmI» [label="«$message»"];
            ||
            apply "//state[@name=$ownState]/event[@name=$message]", 1
                    with "secondDeviceState", "$secondDeviceState",
                    with "thirdDeviceState", "$thirdDeviceState",
                    with "whoAmI", "$whoAmI",
                    with "secondDevice", "$secondDevice",
                    with "thirdDevice", "$thirdDevice",
                    with "depth", "$depth",
                    with "msc", "$msc";
    } //template

    template "protocol/fsm[1]/*/event" {
        param "secondDeviceState";
        param "thirdDeviceState";
        param "whoAmI";
        param "secondDevice";
        param "thirdDevice";
        param "msc";
        param "log";
        param "depth";

        // Some messages and transitions are conditional
        for ("descendant::condition|descendant::else") {
            // Include conditions in MSC
            const "newmsc" {
                | «$msc» 
                call "writeConditions" with "whoAmI", "$whoAmI";
            }
            call "nextStep"
                with "secondDeviceState", "$secondDeviceState",
                with "thirdDeviceState", "$thirdDeviceState",
                with "whoAmI", "$whoAmI",
                with "secondDevice", "$secondDevice",
                with "thirdDevice", "$thirdDevice",
                with "msc", "$newmsc",
                with "log", "$log",
                with "depth", "$depth";
        } // for condition
        // Some messages and transitions aren't conditional
        value "$secondDeviceState";
        call "nextStep"
            with "secondDeviceState", "$secondDeviceState",
            with "thirdDeviceState", "$thirdDeviceState",
            with "whoAmI", "$whoAmI",
            with "secondDevice", "$secondDevice",
            with "thirdDevice", "$thirdDevice",
            with "msc", "$msc",
            with "log", "$log",
            with "depth", "$depth";
    } //template event

    // This is a function, which means it gets called with the previous event or a condition therein.
    function "nextStep" {
        param "secondDeviceState";
        param "thirdDeviceState";
        param "whoAmI";
        param "secondDevice";
        param "thirdDevice";
        param "msc";
        param "depth";
        param "log";
        const "event", "ancestor-or-self::event/@name";
        const "ownState", "ancestor::state/@name";
        // Include user actions in MSC
        const "eventString" if "/protocol/fsm[1]/external[@name=$event]" {
           | u -> «$whoAmI» [label="«$event»"];
                };
        // This is here only for the log:
        const "condition", "ancestor-or-self::condition/@name";
        // There can only be one transition, but we don't rely on uniqueness and take the first
        const "target", "child::transition[1]/@target";   
        // The ground condition for the recursion is still ugly, but it's doing it's job.
        // I'd like to get rid of that depth stuff and find a better condition for a stop
        // for sequences without transitions.
        const "stopCondition", "(((ancestor::state/@timeout='off' and not($target)) or //state[@name=$target]/@timeout='off') and //state[@name=$secondDeviceState]/@timeout='off' and //state[@name=$thirdDeviceState]/@timeout='off' and $depth>$mindepth) or $depth>$maxdepth or ($secondDeviceState='End' and $thirdDeviceState='End' and $target='End')";
        // TODO: This is the most important thing to do
        // This is the message we're going to send
        // they are sent to different receipients
        // and for the three-way thing we need to do that
        if "boolean(child::send)" {
            | «count(child::send)» message(s)
            for "child::send" {
                const "message", "@name";
                // Here we prepare a search string for loop detection
                const "search" {
                    | «$whoAmI» -> «$secondDevice» [label="«$message»"];
                };
                choose {
                    // First check for abort condition(s)
                    // Now we only check for loops.
                    // In that case we print the log and go to another recursion path.
                    when "contains($msc, $search)" {
                        value "$newlog"
                        | loop detected «$depth»
                    }
                    // Then for ground conditions
                    when "$stopCondition" {
                        call "lastStep"
//                            with "newlog", "$newlog",
                            with "target", "$target",
                            with "whoAmI", "$whoAmI",
                            with "ownState", "$ownState",
                            with "secondDeviceState", "$secondDeviceState",
                            with "thirdDeviceState", "$thirdDeviceState",
                            with "secondDevice", "$secondDevice",
                            with "thirdDevice", "$thirdDevice",
                            with "msc", "$msc",
                            with "depth", "$depth";
                    }
                    // Then choose the path to proceed
                    // In case we send a message but don't change our own state
                    when "$message and ($target=$ownState or not($target))" {
                        const "newmsc" {
                            value "$msc";
                            |   «$eventString»
                            |   «$whoAmI» -> «$secondDevice» [label="«$message»"];
                            |   «$whoAmI» -> «$thirdDevice» [label="«$message»"];
                        };
                        const "nextlog" {
//                            value "$newlog";
                            |  b «$depth» 
                        };
                        value "$secondDeviceState";
                        value "$nextlog";
                        apply "/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name=$message]"
                            with "secondDeviceState", "$ownState",
                            with "thirdDeviceState", "$thirdDeviceState",
                            with "whoAmI", "$secondDevice",
                            with "secondDevice", "$whoAmI",
                            with "thirdDevice", "$thirdDevice",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc";
                        apply "/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name=$message]"
                            with "thirdDeviceState", "$ownState",
                            with "secondDeviceState", "$thirdDeviceState",
                            with "whoAmI", "$secondDevice",
                            with "thirdDevice", "$whoAmI",
                            with "secondDevice", "$thirdDevice",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc";
                    }
                    // In case we send a message and change our own state
                    // Previously existence of $eventString was mandatory, not sure if it should
                    when "$message and $target and not($target=$ownState)" {
                        const "nextlog" {
//                            value "$newlog";
                            |  c «$depth» , «$eventString»
                        };
                    const "newmsc" {
                            value "$msc";
                            |   «$eventString»
                            |   «$whoAmI» -> «$secondDevice» [label="«$message»"];
                            |   «$whoAmI» -> «$thirdDevice» [label="«$message»"];
                            |   «$whoAmI» box «$whoAmI»     [label="«$target»"];
                        };
                        apply "/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name=$message]"
                            with "secondDeviceState", "$target",
                            with "thirdDeviceState", "$thirdDeviceState",
                            with "whoAmI", "$secondDevice",
                            with "secondDevice", "$whoAmI",
                            with "thirdDevice", "$thirdDevice",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc";
                        apply "/protocol/fsm[1]/state[@name=$secondDeviceState]/event[@name=$message]"
                            with "thirdDeviceState", "$target",
                            with "secondDeviceState", "$thirdDeviceState",
                            with "whoAmI", "$secondDevice",
                            with "thirdDevice", "$whoAmI",
                            with "secondDevice", "$thirdDevice",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc";
                        // Use every possible user input (will be ignored if none is accepted)
                        call "nexternal"
                            with "secondDeviceState", "$secondDeviceState",
                            with "thirdDeviceState", "$thirdDeviceState",
                            with "whoAmI", "$whoAmI",
                            with "secondDevice", "$secondDevice",
                            with "thirdDevice", "$thirdDevice",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc",
                            with "target", "$target";
                        call "nexternal"
                            with "thirdDeviceState", "$secondDeviceState",
                            with "secondDeviceState", "$thirdDeviceState",
                            with "whoAmI", "$whoAmI",
                            with "thirdDevice", "$secondDevice",
                            with "secondDevice", "$thirdDevice",
                            with "depth", "$depth+1",
                            with "log", "$nextlog",
                            with "msc", "$newmsc",
                            with "target", "$target";
                    }
                    // This should never be entered
                    otherwise {
//                        value "$newlog"
                        | o «$depth»
                    }
                } //choose
            }
        }
        if "not(boolean(child::send))" {
            | No message
            choose {
                // In case we send nothing but change our state and wait for user input
                when "not($message) and $target and not($target=$ownState)" {
                    const "nextlog" {
//                        value "$newlog";
                        |  d «$depth», «$eventString»
                    };
                    const "newmsc" {
                        value "$msc";
                        |   «$eventString»
                        |   «$whoAmI» box «$whoAmI» [label="«$target»"];
                    };
                    // Use every possible user input
                    call "nexternal"
                        with "secondDeviceState", "$secondDeviceState",
                        with "thirdDeviceState", "$thirdDeviceState",
                        with "whoAmI", "$whoAmI",
                        with "secondDevice", "$secondDevice",
                        with "thirdDevice", "$thirdDevice",
                        with "depth", "$depth+1",
                        with "log", "$nextlog",
                        with "msc", "$newmsc",
                        with "target", "$target";
                }
                // This should never be entered
                otherwise {
 //                   value "$newlog"
                    | o «$depth»
                }
            } //choose
        }

//        // amend the log
//        const "newlog" {
//         value "$log";
//         | ----------------------------------------------------------------------------------
//         | «$whoAmI»: at «$ownState» on «$event» if «$condition» send «$message» go «$target» 
//         | «$secondDevice»: «$secondDeviceState»
//         | «$thirdDevice»: «$thirdDeviceState»
//         | stop «//state[@name=$ownState]/@timeout» and  «//state[@name=$secondDeviceState]/@timeout» and «//state[@name=$thirdDeviceState]/@timeout» and «$depth»>«$mindepth»
//         | stop «$stopCondition»
//        };
    } //function nextStep


    function "lastStep" {
        param "newlog";
        param "target";
        param "whoAmI";
        param "ownState";
        param "secondDeviceState";
        param "thirdDeviceState";
        param "secondDevice";
        param "thirdDevice";
        param "msc";
        param "depth";
        // We generate a hopefully unique filename from random numbers
        const "secid", "math:random()";
        const "id", "concat(generate-id(),substring($secid,3,6))";
        // For the footer of the MSC
        const "stateString" choose {
            when ("$target and not($target=$ownState)") {
            |    «$whoAmI» box «$whoAmI» [label="«$target»"],
            }
            otherwise {
            |    «$whoAmI» box «$whoAmI» [label="«$ownState»"],
            }
        };
        // We write the log
        | ===========================================================================
        | doc «$depth», «$id»:
        value "$newlog";
        | STOP
        // and write the finished MSC into a text file
        document "msc/{$id}.msc" method="text" {
            | msc {
            |    «$msc»
            value "$stateString";
            |    «$secondDevice» box «$secondDevice» [label="«$secondDeviceState»"],
            |    «$thirdDevice» box «$thirdDevice» [label="«$thirdDeviceState»"];
            | }
        }
    } //function lastStep

    // A helper function to write conditional clauses into the MSC
    function "writeConditions" {
        param "whoAmI";
        for ("ancestor-or-self::condition|ancestor-or-self::else") {
            const "name" {
                choose {
                    // are we in the if clause
                    when "@name" 
                        value "@name";
                    // or are we in the else clause
                    otherwise
                        > not «preceding-sibling::condition/@name»
                }
            }
                | «$whoAmI» abox «$whoAmI» [label="«$name»"];
        }
    }

    // Because we need this more than once:
    function "nexternal" {
        param "secondDeviceState";
        param "thirdDeviceState";
        param "whoAmI";
        param "secondDevice";
        param "thirdDevice";
        param "depth";
        param "log";
        param "msc";
        param "target";
        for "/protocol/fsm[1]/state[@name=$target]/event" {
            const "name", "@name";
            if "boolean(/protocol/fsm[1]/external[@name=$name])" {
                apply "."
                    with "secondDeviceState", "$secondDeviceState",
                    with "thirdDeviceState", "$thirdDeviceState",
                    with "whoAmI", "$whoAmI",
                    with "secondDevice", "$secondDevice",
                    with "thirdDevice", "$thirdDevice",
                    with "depth", "$depth+1",
                    with "log", "$log",
                    with "msc", "$msc";
            }
        }
    }
} //tstylesheet

